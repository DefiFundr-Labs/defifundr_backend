// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: companies.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCompany = `-- name: CreateCompany :one
INSERT INTO companies (
  id,
  owner_id,
  company_name,
  company_email,
  company_phone,
  company_size,
  company_industry,
  company_description,
  company_headquarters,
  company_logo,
  company_website,
  primary_contact_name,
  primary_contact_email,
  primary_contact_phone,
  company_address,
  company_city,
  company_postal_code,
  company_country,
  company_registration_number,
  registration_country,
  tax_id,
  incorporation_date,
  account_status,
  kyb_status,
  kyb_verified_at,
  kyb_verification_method,
  kyb_verification_provider,
  kyb_rejection_reason,
  legal_entity_type,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $20,
  $21,
  $22,
  COALESCE($23, 'pending'),
  COALESCE($24, 'pending'),
  $25,
  $26,
  $27,
  $28,
  $29,
  COALESCE($30, NOW()),
  COALESCE($31, NOW())
) RETURNING id, owner_id, company_name, company_email, company_phone, company_size, company_industry, company_description, company_headquarters, company_logo, company_website, primary_contact_name, primary_contact_email, primary_contact_phone, company_address, company_city, company_postal_code, company_country, company_registration_number, registration_country, tax_id, incorporation_date, account_status, kyb_status, kyb_verified_at, kyb_verification_method, kyb_verification_provider, kyb_rejection_reason, legal_entity_type, created_at, updated_at
`

type CreateCompanyParams struct {
	ID                        interface{}        `json:"id"`
	OwnerID                   uuid.UUID          `json:"owner_id"`
	CompanyName               string             `json:"company_name"`
	CompanyEmail              pgtype.Text        `json:"company_email"`
	CompanyPhone              pgtype.Text        `json:"company_phone"`
	CompanySize               pgtype.Text        `json:"company_size"`
	CompanyIndustry           pgtype.Text        `json:"company_industry"`
	CompanyDescription        pgtype.Text        `json:"company_description"`
	CompanyHeadquarters       pgtype.Text        `json:"company_headquarters"`
	CompanyLogo               pgtype.Text        `json:"company_logo"`
	CompanyWebsite            pgtype.Text        `json:"company_website"`
	PrimaryContactName        pgtype.Text        `json:"primary_contact_name"`
	PrimaryContactEmail       pgtype.Text        `json:"primary_contact_email"`
	PrimaryContactPhone       pgtype.Text        `json:"primary_contact_phone"`
	CompanyAddress            pgtype.Text        `json:"company_address"`
	CompanyCity               pgtype.Text        `json:"company_city"`
	CompanyPostalCode         pgtype.Text        `json:"company_postal_code"`
	CompanyCountry            pgtype.Text        `json:"company_country"`
	CompanyRegistrationNumber pgtype.Text        `json:"company_registration_number"`
	RegistrationCountry       pgtype.Text        `json:"registration_country"`
	TaxID                     pgtype.Text        `json:"tax_id"`
	IncorporationDate         pgtype.Date        `json:"incorporation_date"`
	AccountStatus             interface{}        `json:"account_status"`
	KybStatus                 interface{}        `json:"kyb_status"`
	KybVerifiedAt             pgtype.Timestamptz `json:"kyb_verified_at"`
	KybVerificationMethod     pgtype.Text        `json:"kyb_verification_method"`
	KybVerificationProvider   pgtype.Text        `json:"kyb_verification_provider"`
	KybRejectionReason        pgtype.Text        `json:"kyb_rejection_reason"`
	LegalEntityType           pgtype.Text        `json:"legal_entity_type"`
	CreatedAt                 interface{}        `json:"created_at"`
	UpdatedAt                 interface{}        `json:"updated_at"`
}

func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) (Companies, error) {
	row := q.db.QueryRow(ctx, createCompany,
		arg.ID,
		arg.OwnerID,
		arg.CompanyName,
		arg.CompanyEmail,
		arg.CompanyPhone,
		arg.CompanySize,
		arg.CompanyIndustry,
		arg.CompanyDescription,
		arg.CompanyHeadquarters,
		arg.CompanyLogo,
		arg.CompanyWebsite,
		arg.PrimaryContactName,
		arg.PrimaryContactEmail,
		arg.PrimaryContactPhone,
		arg.CompanyAddress,
		arg.CompanyCity,
		arg.CompanyPostalCode,
		arg.CompanyCountry,
		arg.CompanyRegistrationNumber,
		arg.RegistrationCountry,
		arg.TaxID,
		arg.IncorporationDate,
		arg.AccountStatus,
		arg.KybStatus,
		arg.KybVerifiedAt,
		arg.KybVerificationMethod,
		arg.KybVerificationProvider,
		arg.KybRejectionReason,
		arg.LegalEntityType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Companies
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.CompanyName,
		&i.CompanyEmail,
		&i.CompanyPhone,
		&i.CompanySize,
		&i.CompanyIndustry,
		&i.CompanyDescription,
		&i.CompanyHeadquarters,
		&i.CompanyLogo,
		&i.CompanyWebsite,
		&i.PrimaryContactName,
		&i.PrimaryContactEmail,
		&i.PrimaryContactPhone,
		&i.CompanyAddress,
		&i.CompanyCity,
		&i.CompanyPostalCode,
		&i.CompanyCountry,
		&i.CompanyRegistrationNumber,
		&i.RegistrationCountry,
		&i.TaxID,
		&i.IncorporationDate,
		&i.AccountStatus,
		&i.KybStatus,
		&i.KybVerifiedAt,
		&i.KybVerificationMethod,
		&i.KybVerificationProvider,
		&i.KybRejectionReason,
		&i.LegalEntityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCompanyEmployee = `-- name: CreateCompanyEmployee :one
INSERT INTO company_employees (
  id,
  company_id,
  user_id,
  employee_id,
  department,
  position,
  employment_status,
  employment_type,
  start_date,
  end_date,
  manager_id,
  salary_amount,
  salary_currency,
  salary_frequency,
  hourly_rate,
  payment_method,
  payment_split,
  tax_information,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  COALESCE($7, 'active'),
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  COALESCE($19, NOW()),
  COALESCE($20, NOW())
) RETURNING id, company_id, user_id, employee_id, department, position, employment_status, employment_type, start_date, end_date, manager_id, salary_amount, salary_currency, salary_frequency, hourly_rate, payment_method, payment_split, tax_information, created_at, updated_at
`

type CreateCompanyEmployeeParams struct {
	ID               interface{}    `json:"id"`
	CompanyID        uuid.UUID      `json:"company_id"`
	UserID           pgtype.UUID    `json:"user_id"`
	EmployeeID       pgtype.Text    `json:"employee_id"`
	Department       pgtype.Text    `json:"department"`
	Position         pgtype.Text    `json:"position"`
	EmploymentStatus interface{}    `json:"employment_status"`
	EmploymentType   pgtype.Text    `json:"employment_type"`
	StartDate        pgtype.Date    `json:"start_date"`
	EndDate          pgtype.Date    `json:"end_date"`
	ManagerID        pgtype.UUID    `json:"manager_id"`
	SalaryAmount     pgtype.Numeric `json:"salary_amount"`
	SalaryCurrency   pgtype.Text    `json:"salary_currency"`
	SalaryFrequency  pgtype.Text    `json:"salary_frequency"`
	HourlyRate       pgtype.Numeric `json:"hourly_rate"`
	PaymentMethod    pgtype.Text    `json:"payment_method"`
	PaymentSplit     []byte         `json:"payment_split"`
	TaxInformation   []byte         `json:"tax_information"`
	CreatedAt        interface{}    `json:"created_at"`
	UpdatedAt        interface{}    `json:"updated_at"`
}

func (q *Queries) CreateCompanyEmployee(ctx context.Context, arg CreateCompanyEmployeeParams) (CompanyEmployees, error) {
	row := q.db.QueryRow(ctx, createCompanyEmployee,
		arg.ID,
		arg.CompanyID,
		arg.UserID,
		arg.EmployeeID,
		arg.Department,
		arg.Position,
		arg.EmploymentStatus,
		arg.EmploymentType,
		arg.StartDate,
		arg.EndDate,
		arg.ManagerID,
		arg.SalaryAmount,
		arg.SalaryCurrency,
		arg.SalaryFrequency,
		arg.HourlyRate,
		arg.PaymentMethod,
		arg.PaymentSplit,
		arg.TaxInformation,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CompanyEmployees
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.EmployeeID,
		&i.Department,
		&i.Position,
		&i.EmploymentStatus,
		&i.EmploymentType,
		&i.StartDate,
		&i.EndDate,
		&i.ManagerID,
		&i.SalaryAmount,
		&i.SalaryCurrency,
		&i.SalaryFrequency,
		&i.HourlyRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.TaxInformation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCompanyUser = `-- name: CreateCompanyUser :one
INSERT INTO company_users (
  id,
  company_id,
  user_id,
  role,
  department,
  job_title,
  is_administrator,
  can_manage_payroll,
  can_manage_invoices,
  can_manage_employees,
  can_manage_company_settings,
  can_manage_bank_accounts,
  can_manage_wallets,
  permissions,
  is_active,
  added_by,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  COALESCE($7, FALSE),
  COALESCE($8, FALSE),
  COALESCE($9, FALSE),
  COALESCE($10, FALSE),
  COALESCE($11, FALSE),
  COALESCE($12, FALSE),
  COALESCE($13, FALSE),
  $14,
  COALESCE($15, TRUE),
  $16,
  COALESCE($17, NOW()),
  COALESCE($18, NOW())
) RETURNING id, company_id, user_id, role, department, job_title, is_administrator, can_manage_payroll, can_manage_invoices, can_manage_employees, can_manage_company_settings, can_manage_bank_accounts, can_manage_wallets, permissions, is_active, added_by, created_at, updated_at
`

type CreateCompanyUserParams struct {
	ID                       interface{} `json:"id"`
	CompanyID                uuid.UUID   `json:"company_id"`
	UserID                   uuid.UUID   `json:"user_id"`
	Role                     string      `json:"role"`
	Department               pgtype.Text `json:"department"`
	JobTitle                 pgtype.Text `json:"job_title"`
	IsAdministrator          interface{} `json:"is_administrator"`
	CanManagePayroll         interface{} `json:"can_manage_payroll"`
	CanManageInvoices        interface{} `json:"can_manage_invoices"`
	CanManageEmployees       interface{} `json:"can_manage_employees"`
	CanManageCompanySettings interface{} `json:"can_manage_company_settings"`
	CanManageBankAccounts    interface{} `json:"can_manage_bank_accounts"`
	CanManageWallets         interface{} `json:"can_manage_wallets"`
	Permissions              []byte      `json:"permissions"`
	IsActive                 interface{} `json:"is_active"`
	AddedBy                  pgtype.UUID `json:"added_by"`
	CreatedAt                interface{} `json:"created_at"`
	UpdatedAt                interface{} `json:"updated_at"`
}

func (q *Queries) CreateCompanyUser(ctx context.Context, arg CreateCompanyUserParams) (CompanyUsers, error) {
	row := q.db.QueryRow(ctx, createCompanyUser,
		arg.ID,
		arg.CompanyID,
		arg.UserID,
		arg.Role,
		arg.Department,
		arg.JobTitle,
		arg.IsAdministrator,
		arg.CanManagePayroll,
		arg.CanManageInvoices,
		arg.CanManageEmployees,
		arg.CanManageCompanySettings,
		arg.CanManageBankAccounts,
		arg.CanManageWallets,
		arg.Permissions,
		arg.IsActive,
		arg.AddedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CompanyUsers
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.Role,
		&i.Department,
		&i.JobTitle,
		&i.IsAdministrator,
		&i.CanManagePayroll,
		&i.CanManageInvoices,
		&i.CanManageEmployees,
		&i.CanManageCompanySettings,
		&i.CanManageBankAccounts,
		&i.CanManageWallets,
		&i.Permissions,
		&i.IsActive,
		&i.AddedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompaniesAccessibleToUser = `-- name: GetCompaniesAccessibleToUser :many
SELECT DISTINCT c.id, c.owner_id, c.company_name, c.company_email, c.company_phone, c.company_size, c.company_industry, c.company_description, c.company_headquarters, c.company_logo, c.company_website, c.primary_contact_name, c.primary_contact_email, c.primary_contact_phone, c.company_address, c.company_city, c.company_postal_code, c.company_country, c.company_registration_number, c.registration_country, c.tax_id, c.incorporation_date, c.account_status, c.kyb_status, c.kyb_verified_at, c.kyb_verification_method, c.kyb_verification_provider, c.kyb_rejection_reason, c.legal_entity_type, c.created_at, c.updated_at
FROM companies c
LEFT JOIN company_users cu ON c.id = cu.company_id
WHERE c.owner_id = $1 OR cu.user_id = $1
ORDER BY c.created_at DESC
`

func (q *Queries) GetCompaniesAccessibleToUser(ctx context.Context, userID uuid.UUID) ([]Companies, error) {
	rows, err := q.db.Query(ctx, getCompaniesAccessibleToUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Companies{}
	for rows.Next() {
		var i Companies
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.CompanyName,
			&i.CompanyEmail,
			&i.CompanyPhone,
			&i.CompanySize,
			&i.CompanyIndustry,
			&i.CompanyDescription,
			&i.CompanyHeadquarters,
			&i.CompanyLogo,
			&i.CompanyWebsite,
			&i.PrimaryContactName,
			&i.PrimaryContactEmail,
			&i.PrimaryContactPhone,
			&i.CompanyAddress,
			&i.CompanyCity,
			&i.CompanyPostalCode,
			&i.CompanyCountry,
			&i.CompanyRegistrationNumber,
			&i.RegistrationCountry,
			&i.TaxID,
			&i.IncorporationDate,
			&i.AccountStatus,
			&i.KybStatus,
			&i.KybVerifiedAt,
			&i.KybVerificationMethod,
			&i.KybVerificationProvider,
			&i.KybRejectionReason,
			&i.LegalEntityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompaniesByOwner = `-- name: GetCompaniesByOwner :many
SELECT id, owner_id, company_name, company_email, company_phone, company_size, company_industry, company_description, company_headquarters, company_logo, company_website, primary_contact_name, primary_contact_email, primary_contact_phone, company_address, company_city, company_postal_code, company_country, company_registration_number, registration_country, tax_id, incorporation_date, account_status, kyb_status, kyb_verified_at, kyb_verification_method, kyb_verification_provider, kyb_rejection_reason, legal_entity_type, created_at, updated_at FROM companies 
WHERE owner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetCompaniesByOwner(ctx context.Context, ownerID uuid.UUID) ([]Companies, error) {
	rows, err := q.db.Query(ctx, getCompaniesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Companies{}
	for rows.Next() {
		var i Companies
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.CompanyName,
			&i.CompanyEmail,
			&i.CompanyPhone,
			&i.CompanySize,
			&i.CompanyIndustry,
			&i.CompanyDescription,
			&i.CompanyHeadquarters,
			&i.CompanyLogo,
			&i.CompanyWebsite,
			&i.PrimaryContactName,
			&i.PrimaryContactEmail,
			&i.PrimaryContactPhone,
			&i.CompanyAddress,
			&i.CompanyCity,
			&i.CompanyPostalCode,
			&i.CompanyCountry,
			&i.CompanyRegistrationNumber,
			&i.RegistrationCountry,
			&i.TaxID,
			&i.IncorporationDate,
			&i.AccountStatus,
			&i.KybStatus,
			&i.KybVerifiedAt,
			&i.KybVerificationMethod,
			&i.KybVerificationProvider,
			&i.KybRejectionReason,
			&i.LegalEntityType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT id, owner_id, company_name, company_email, company_phone, company_size, company_industry, company_description, company_headquarters, company_logo, company_website, primary_contact_name, primary_contact_email, primary_contact_phone, company_address, company_city, company_postal_code, company_country, company_registration_number, registration_country, tax_id, incorporation_date, account_status, kyb_status, kyb_verified_at, kyb_verification_method, kyb_verification_provider, kyb_rejection_reason, legal_entity_type, created_at, updated_at FROM companies WHERE id = $1
`

func (q *Queries) GetCompanyByID(ctx context.Context, id uuid.UUID) (Companies, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, id)
	var i Companies
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.CompanyName,
		&i.CompanyEmail,
		&i.CompanyPhone,
		&i.CompanySize,
		&i.CompanyIndustry,
		&i.CompanyDescription,
		&i.CompanyHeadquarters,
		&i.CompanyLogo,
		&i.CompanyWebsite,
		&i.PrimaryContactName,
		&i.PrimaryContactEmail,
		&i.PrimaryContactPhone,
		&i.CompanyAddress,
		&i.CompanyCity,
		&i.CompanyPostalCode,
		&i.CompanyCountry,
		&i.CompanyRegistrationNumber,
		&i.RegistrationCountry,
		&i.TaxID,
		&i.IncorporationDate,
		&i.AccountStatus,
		&i.KybStatus,
		&i.KybVerifiedAt,
		&i.KybVerificationMethod,
		&i.KybVerificationProvider,
		&i.KybRejectionReason,
		&i.LegalEntityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyEmployeeByID = `-- name: GetCompanyEmployeeByID :one
SELECT ce.id, ce.company_id, ce.user_id, ce.employee_id, ce.department, ce.position, ce.employment_status, ce.employment_type, ce.start_date, ce.end_date, ce.manager_id, ce.salary_amount, ce.salary_currency, ce.salary_frequency, ce.hourly_rate, ce.payment_method, ce.payment_split, ce.tax_information, ce.created_at, ce.updated_at, 
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM company_employees ce
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE ce.id = $1
`

type GetCompanyEmployeeByIDRow struct {
	ID               uuid.UUID          `json:"id"`
	CompanyID        uuid.UUID          `json:"company_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	EmployeeID       pgtype.Text        `json:"employee_id"`
	Department       pgtype.Text        `json:"department"`
	Position         pgtype.Text        `json:"position"`
	EmploymentStatus pgtype.Text        `json:"employment_status"`
	EmploymentType   pgtype.Text        `json:"employment_type"`
	StartDate        pgtype.Date        `json:"start_date"`
	EndDate          pgtype.Date        `json:"end_date"`
	ManagerID        pgtype.UUID        `json:"manager_id"`
	SalaryAmount     pgtype.Numeric     `json:"salary_amount"`
	SalaryCurrency   pgtype.Text        `json:"salary_currency"`
	SalaryFrequency  pgtype.Text        `json:"salary_frequency"`
	HourlyRate       pgtype.Numeric     `json:"hourly_rate"`
	PaymentMethod    pgtype.Text        `json:"payment_method"`
	PaymentSplit     []byte             `json:"payment_split"`
	TaxInformation   []byte             `json:"tax_information"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	Email            pgtype.Text        `json:"email"`
	FirstName        pgtype.Text        `json:"first_name"`
	LastName         pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetCompanyEmployeeByID(ctx context.Context, id uuid.UUID) (GetCompanyEmployeeByIDRow, error) {
	row := q.db.QueryRow(ctx, getCompanyEmployeeByID, id)
	var i GetCompanyEmployeeByIDRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.EmployeeID,
		&i.Department,
		&i.Position,
		&i.EmploymentStatus,
		&i.EmploymentType,
		&i.StartDate,
		&i.EndDate,
		&i.ManagerID,
		&i.SalaryAmount,
		&i.SalaryCurrency,
		&i.SalaryFrequency,
		&i.HourlyRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.TaxInformation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getCompanyEmployeesByCompany = `-- name: GetCompanyEmployeesByCompany :many
SELECT ce.id, ce.company_id, ce.user_id, ce.employee_id, ce.department, ce.position, ce.employment_status, ce.employment_type, ce.start_date, ce.end_date, ce.manager_id, ce.salary_amount, ce.salary_currency, ce.salary_frequency, ce.hourly_rate, ce.payment_method, ce.payment_split, ce.tax_information, ce.created_at, ce.updated_at, 
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM company_employees ce
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE ce.company_id = $1
ORDER BY ce.created_at DESC
`

type GetCompanyEmployeesByCompanyRow struct {
	ID               uuid.UUID          `json:"id"`
	CompanyID        uuid.UUID          `json:"company_id"`
	UserID           pgtype.UUID        `json:"user_id"`
	EmployeeID       pgtype.Text        `json:"employee_id"`
	Department       pgtype.Text        `json:"department"`
	Position         pgtype.Text        `json:"position"`
	EmploymentStatus pgtype.Text        `json:"employment_status"`
	EmploymentType   pgtype.Text        `json:"employment_type"`
	StartDate        pgtype.Date        `json:"start_date"`
	EndDate          pgtype.Date        `json:"end_date"`
	ManagerID        pgtype.UUID        `json:"manager_id"`
	SalaryAmount     pgtype.Numeric     `json:"salary_amount"`
	SalaryCurrency   pgtype.Text        `json:"salary_currency"`
	SalaryFrequency  pgtype.Text        `json:"salary_frequency"`
	HourlyRate       pgtype.Numeric     `json:"hourly_rate"`
	PaymentMethod    pgtype.Text        `json:"payment_method"`
	PaymentSplit     []byte             `json:"payment_split"`
	TaxInformation   []byte             `json:"tax_information"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	Email            pgtype.Text        `json:"email"`
	FirstName        pgtype.Text        `json:"first_name"`
	LastName         pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetCompanyEmployeesByCompany(ctx context.Context, companyID uuid.UUID) ([]GetCompanyEmployeesByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getCompanyEmployeesByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyEmployeesByCompanyRow{}
	for rows.Next() {
		var i GetCompanyEmployeesByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.EmployeeID,
			&i.Department,
			&i.Position,
			&i.EmploymentStatus,
			&i.EmploymentType,
			&i.StartDate,
			&i.EndDate,
			&i.ManagerID,
			&i.SalaryAmount,
			&i.SalaryCurrency,
			&i.SalaryFrequency,
			&i.HourlyRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.TaxInformation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyUser = `-- name: GetCompanyUser :one
SELECT cu.id, cu.company_id, cu.user_id, cu.role, cu.department, cu.job_title, cu.is_administrator, cu.can_manage_payroll, cu.can_manage_invoices, cu.can_manage_employees, cu.can_manage_company_settings, cu.can_manage_bank_accounts, cu.can_manage_wallets, cu.permissions, cu.is_active, cu.added_by, cu.created_at, cu.updated_at, u.email, u.account_status,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM company_users cu
JOIN users u ON cu.user_id = u.id
LEFT JOIN company_staff_profiles csp ON cu.id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE cu.company_id = $1 AND cu.user_id = $2
`

type GetCompanyUserParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	UserID    uuid.UUID `json:"user_id"`
}

type GetCompanyUserRow struct {
	ID                       uuid.UUID          `json:"id"`
	CompanyID                uuid.UUID          `json:"company_id"`
	UserID                   uuid.UUID          `json:"user_id"`
	Role                     string             `json:"role"`
	Department               pgtype.Text        `json:"department"`
	JobTitle                 pgtype.Text        `json:"job_title"`
	IsAdministrator          pgtype.Bool        `json:"is_administrator"`
	CanManagePayroll         pgtype.Bool        `json:"can_manage_payroll"`
	CanManageInvoices        pgtype.Bool        `json:"can_manage_invoices"`
	CanManageEmployees       pgtype.Bool        `json:"can_manage_employees"`
	CanManageCompanySettings pgtype.Bool        `json:"can_manage_company_settings"`
	CanManageBankAccounts    pgtype.Bool        `json:"can_manage_bank_accounts"`
	CanManageWallets         pgtype.Bool        `json:"can_manage_wallets"`
	Permissions              []byte             `json:"permissions"`
	IsActive                 pgtype.Bool        `json:"is_active"`
	AddedBy                  pgtype.UUID        `json:"added_by"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	Email                    string             `json:"email"`
	AccountStatus            pgtype.Text        `json:"account_status"`
	FirstName                pgtype.Text        `json:"first_name"`
	LastName                 pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetCompanyUser(ctx context.Context, arg GetCompanyUserParams) (GetCompanyUserRow, error) {
	row := q.db.QueryRow(ctx, getCompanyUser, arg.CompanyID, arg.UserID)
	var i GetCompanyUserRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.Role,
		&i.Department,
		&i.JobTitle,
		&i.IsAdministrator,
		&i.CanManagePayroll,
		&i.CanManageInvoices,
		&i.CanManageEmployees,
		&i.CanManageCompanySettings,
		&i.CanManageBankAccounts,
		&i.CanManageWallets,
		&i.Permissions,
		&i.IsActive,
		&i.AddedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.AccountStatus,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getCompanyUsersByCompany = `-- name: GetCompanyUsersByCompany :many
SELECT cu.id, cu.company_id, cu.user_id, cu.role, cu.department, cu.job_title, cu.is_administrator, cu.can_manage_payroll, cu.can_manage_invoices, cu.can_manage_employees, cu.can_manage_company_settings, cu.can_manage_bank_accounts, cu.can_manage_wallets, cu.permissions, cu.is_active, cu.added_by, cu.created_at, cu.updated_at, u.email, u.account_status,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM company_users cu
JOIN users u ON cu.user_id = u.id
LEFT JOIN company_staff_profiles csp ON cu.id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE cu.company_id = $1 AND cu.is_active = TRUE
ORDER BY cu.created_at DESC
`

type GetCompanyUsersByCompanyRow struct {
	ID                       uuid.UUID          `json:"id"`
	CompanyID                uuid.UUID          `json:"company_id"`
	UserID                   uuid.UUID          `json:"user_id"`
	Role                     string             `json:"role"`
	Department               pgtype.Text        `json:"department"`
	JobTitle                 pgtype.Text        `json:"job_title"`
	IsAdministrator          pgtype.Bool        `json:"is_administrator"`
	CanManagePayroll         pgtype.Bool        `json:"can_manage_payroll"`
	CanManageInvoices        pgtype.Bool        `json:"can_manage_invoices"`
	CanManageEmployees       pgtype.Bool        `json:"can_manage_employees"`
	CanManageCompanySettings pgtype.Bool        `json:"can_manage_company_settings"`
	CanManageBankAccounts    pgtype.Bool        `json:"can_manage_bank_accounts"`
	CanManageWallets         pgtype.Bool        `json:"can_manage_wallets"`
	Permissions              []byte             `json:"permissions"`
	IsActive                 pgtype.Bool        `json:"is_active"`
	AddedBy                  pgtype.UUID        `json:"added_by"`
	CreatedAt                pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                pgtype.Timestamptz `json:"updated_at"`
	Email                    string             `json:"email"`
	AccountStatus            pgtype.Text        `json:"account_status"`
	FirstName                pgtype.Text        `json:"first_name"`
	LastName                 pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetCompanyUsersByCompany(ctx context.Context, companyID uuid.UUID) ([]GetCompanyUsersByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getCompanyUsersByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyUsersByCompanyRow{}
	for rows.Next() {
		var i GetCompanyUsersByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.UserID,
			&i.Role,
			&i.Department,
			&i.JobTitle,
			&i.IsAdministrator,
			&i.CanManagePayroll,
			&i.CanManageInvoices,
			&i.CanManageEmployees,
			&i.CanManageCompanySettings,
			&i.CanManageBankAccounts,
			&i.CanManageWallets,
			&i.Permissions,
			&i.IsActive,
			&i.AddedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.AccountStatus,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCompany = `-- name: UpdateCompany :one
UPDATE companies SET
  company_name = COALESCE($1, company_name),
  company_email = COALESCE($2, company_email),
  company_phone = COALESCE($3, company_phone),
  company_size = COALESCE($4, company_size),
  company_industry = COALESCE($5, company_industry),
  company_description = COALESCE($6, company_description),
  company_headquarters = COALESCE($7, company_headquarters),
  company_logo = COALESCE($8, company_logo),
  company_website = COALESCE($9, company_website),
  primary_contact_name = COALESCE($10, primary_contact_name),
  primary_contact_email = COALESCE($11, primary_contact_email),
  primary_contact_phone = COALESCE($12, primary_contact_phone),
  company_address = COALESCE($13, company_address),
  company_city = COALESCE($14, company_city),
  company_postal_code = COALESCE($15, company_postal_code),
  company_country = COALESCE($16, company_country),
  company_registration_number = COALESCE($17, company_registration_number),
  registration_country = COALESCE($18, registration_country),
  tax_id = COALESCE($19, tax_id),
  incorporation_date = COALESCE($20, incorporation_date),
  account_status = COALESCE($21, account_status),
  kyb_status = COALESCE($22, kyb_status),
  kyb_verified_at = COALESCE($23, kyb_verified_at),
  kyb_verification_method = COALESCE($24, kyb_verification_method),
  kyb_verification_provider = COALESCE($25, kyb_verification_provider),
  kyb_rejection_reason = COALESCE($26, kyb_rejection_reason),
  legal_entity_type = COALESCE($27, legal_entity_type),
  updated_at = NOW()
WHERE id = $28
RETURNING id, owner_id, company_name, company_email, company_phone, company_size, company_industry, company_description, company_headquarters, company_logo, company_website, primary_contact_name, primary_contact_email, primary_contact_phone, company_address, company_city, company_postal_code, company_country, company_registration_number, registration_country, tax_id, incorporation_date, account_status, kyb_status, kyb_verified_at, kyb_verification_method, kyb_verification_provider, kyb_rejection_reason, legal_entity_type, created_at, updated_at
`

type UpdateCompanyParams struct {
	CompanyName               string             `json:"company_name"`
	CompanyEmail              pgtype.Text        `json:"company_email"`
	CompanyPhone              pgtype.Text        `json:"company_phone"`
	CompanySize               pgtype.Text        `json:"company_size"`
	CompanyIndustry           pgtype.Text        `json:"company_industry"`
	CompanyDescription        pgtype.Text        `json:"company_description"`
	CompanyHeadquarters       pgtype.Text        `json:"company_headquarters"`
	CompanyLogo               pgtype.Text        `json:"company_logo"`
	CompanyWebsite            pgtype.Text        `json:"company_website"`
	PrimaryContactName        pgtype.Text        `json:"primary_contact_name"`
	PrimaryContactEmail       pgtype.Text        `json:"primary_contact_email"`
	PrimaryContactPhone       pgtype.Text        `json:"primary_contact_phone"`
	CompanyAddress            pgtype.Text        `json:"company_address"`
	CompanyCity               pgtype.Text        `json:"company_city"`
	CompanyPostalCode         pgtype.Text        `json:"company_postal_code"`
	CompanyCountry            pgtype.Text        `json:"company_country"`
	CompanyRegistrationNumber pgtype.Text        `json:"company_registration_number"`
	RegistrationCountry       pgtype.Text        `json:"registration_country"`
	TaxID                     pgtype.Text        `json:"tax_id"`
	IncorporationDate         pgtype.Date        `json:"incorporation_date"`
	AccountStatus             pgtype.Text        `json:"account_status"`
	KybStatus                 pgtype.Text        `json:"kyb_status"`
	KybVerifiedAt             pgtype.Timestamptz `json:"kyb_verified_at"`
	KybVerificationMethod     pgtype.Text        `json:"kyb_verification_method"`
	KybVerificationProvider   pgtype.Text        `json:"kyb_verification_provider"`
	KybRejectionReason        pgtype.Text        `json:"kyb_rejection_reason"`
	LegalEntityType           pgtype.Text        `json:"legal_entity_type"`
	ID                        uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateCompany(ctx context.Context, arg UpdateCompanyParams) (Companies, error) {
	row := q.db.QueryRow(ctx, updateCompany,
		arg.CompanyName,
		arg.CompanyEmail,
		arg.CompanyPhone,
		arg.CompanySize,
		arg.CompanyIndustry,
		arg.CompanyDescription,
		arg.CompanyHeadquarters,
		arg.CompanyLogo,
		arg.CompanyWebsite,
		arg.PrimaryContactName,
		arg.PrimaryContactEmail,
		arg.PrimaryContactPhone,
		arg.CompanyAddress,
		arg.CompanyCity,
		arg.CompanyPostalCode,
		arg.CompanyCountry,
		arg.CompanyRegistrationNumber,
		arg.RegistrationCountry,
		arg.TaxID,
		arg.IncorporationDate,
		arg.AccountStatus,
		arg.KybStatus,
		arg.KybVerifiedAt,
		arg.KybVerificationMethod,
		arg.KybVerificationProvider,
		arg.KybRejectionReason,
		arg.LegalEntityType,
		arg.ID,
	)
	var i Companies
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.CompanyName,
		&i.CompanyEmail,
		&i.CompanyPhone,
		&i.CompanySize,
		&i.CompanyIndustry,
		&i.CompanyDescription,
		&i.CompanyHeadquarters,
		&i.CompanyLogo,
		&i.CompanyWebsite,
		&i.PrimaryContactName,
		&i.PrimaryContactEmail,
		&i.PrimaryContactPhone,
		&i.CompanyAddress,
		&i.CompanyCity,
		&i.CompanyPostalCode,
		&i.CompanyCountry,
		&i.CompanyRegistrationNumber,
		&i.RegistrationCountry,
		&i.TaxID,
		&i.IncorporationDate,
		&i.AccountStatus,
		&i.KybStatus,
		&i.KybVerifiedAt,
		&i.KybVerificationMethod,
		&i.KybVerificationProvider,
		&i.KybRejectionReason,
		&i.LegalEntityType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCompanyEmployee = `-- name: UpdateCompanyEmployee :one
UPDATE company_employees SET
  employee_id = COALESCE($1, employee_id),
  department = COALESCE($2, department),
  position = COALESCE($3, position),
  employment_status = COALESCE($4, employment_status),
  employment_type = COALESCE($5, employment_type),
  start_date = COALESCE($6, start_date),
  end_date = COALESCE($7, end_date),
  manager_id = COALESCE($8, manager_id),
  salary_amount = COALESCE($9, salary_amount),
  salary_currency = COALESCE($10, salary_currency),
  salary_frequency = COALESCE($11, salary_frequency),
  hourly_rate = COALESCE($12, hourly_rate),
  payment_method = COALESCE($13, payment_method),
  payment_split = COALESCE($14, payment_split),
  tax_information = COALESCE($15, tax_information),
  updated_at = NOW()
WHERE id = $16
RETURNING id, company_id, user_id, employee_id, department, position, employment_status, employment_type, start_date, end_date, manager_id, salary_amount, salary_currency, salary_frequency, hourly_rate, payment_method, payment_split, tax_information, created_at, updated_at
`

type UpdateCompanyEmployeeParams struct {
	EmployeeID       pgtype.Text    `json:"employee_id"`
	Department       pgtype.Text    `json:"department"`
	Position         pgtype.Text    `json:"position"`
	EmploymentStatus pgtype.Text    `json:"employment_status"`
	EmploymentType   pgtype.Text    `json:"employment_type"`
	StartDate        pgtype.Date    `json:"start_date"`
	EndDate          pgtype.Date    `json:"end_date"`
	ManagerID        pgtype.UUID    `json:"manager_id"`
	SalaryAmount     pgtype.Numeric `json:"salary_amount"`
	SalaryCurrency   pgtype.Text    `json:"salary_currency"`
	SalaryFrequency  pgtype.Text    `json:"salary_frequency"`
	HourlyRate       pgtype.Numeric `json:"hourly_rate"`
	PaymentMethod    pgtype.Text    `json:"payment_method"`
	PaymentSplit     []byte         `json:"payment_split"`
	TaxInformation   []byte         `json:"tax_information"`
	ID               uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateCompanyEmployee(ctx context.Context, arg UpdateCompanyEmployeeParams) (CompanyEmployees, error) {
	row := q.db.QueryRow(ctx, updateCompanyEmployee,
		arg.EmployeeID,
		arg.Department,
		arg.Position,
		arg.EmploymentStatus,
		arg.EmploymentType,
		arg.StartDate,
		arg.EndDate,
		arg.ManagerID,
		arg.SalaryAmount,
		arg.SalaryCurrency,
		arg.SalaryFrequency,
		arg.HourlyRate,
		arg.PaymentMethod,
		arg.PaymentSplit,
		arg.TaxInformation,
		arg.ID,
	)
	var i CompanyEmployees
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.EmployeeID,
		&i.Department,
		&i.Position,
		&i.EmploymentStatus,
		&i.EmploymentType,
		&i.StartDate,
		&i.EndDate,
		&i.ManagerID,
		&i.SalaryAmount,
		&i.SalaryCurrency,
		&i.SalaryFrequency,
		&i.HourlyRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.TaxInformation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCompanyUser = `-- name: UpdateCompanyUser :one
UPDATE company_users SET
  role = COALESCE($1, role),
  department = COALESCE($2, department),
  job_title = COALESCE($3, job_title),
  is_administrator = COALESCE($4, is_administrator),
  can_manage_payroll = COALESCE($5, can_manage_payroll),
  can_manage_invoices = COALESCE($6, can_manage_invoices),
  can_manage_employees = COALESCE($7, can_manage_employees),
  can_manage_company_settings = COALESCE($8, can_manage_company_settings),
  can_manage_bank_accounts = COALESCE($9, can_manage_bank_accounts),
  can_manage_wallets = COALESCE($10, can_manage_wallets),
  permissions = COALESCE($11, permissions),
  is_active = COALESCE($12, is_active),
  updated_at = NOW()
WHERE company_id = $13 AND user_id = $14
RETURNING id, company_id, user_id, role, department, job_title, is_administrator, can_manage_payroll, can_manage_invoices, can_manage_employees, can_manage_company_settings, can_manage_bank_accounts, can_manage_wallets, permissions, is_active, added_by, created_at, updated_at
`

type UpdateCompanyUserParams struct {
	Role                     string      `json:"role"`
	Department               pgtype.Text `json:"department"`
	JobTitle                 pgtype.Text `json:"job_title"`
	IsAdministrator          pgtype.Bool `json:"is_administrator"`
	CanManagePayroll         pgtype.Bool `json:"can_manage_payroll"`
	CanManageInvoices        pgtype.Bool `json:"can_manage_invoices"`
	CanManageEmployees       pgtype.Bool `json:"can_manage_employees"`
	CanManageCompanySettings pgtype.Bool `json:"can_manage_company_settings"`
	CanManageBankAccounts    pgtype.Bool `json:"can_manage_bank_accounts"`
	CanManageWallets         pgtype.Bool `json:"can_manage_wallets"`
	Permissions              []byte      `json:"permissions"`
	IsActive                 pgtype.Bool `json:"is_active"`
	CompanyID                uuid.UUID   `json:"company_id"`
	UserID                   uuid.UUID   `json:"user_id"`
}

func (q *Queries) UpdateCompanyUser(ctx context.Context, arg UpdateCompanyUserParams) (CompanyUsers, error) {
	row := q.db.QueryRow(ctx, updateCompanyUser,
		arg.Role,
		arg.Department,
		arg.JobTitle,
		arg.IsAdministrator,
		arg.CanManagePayroll,
		arg.CanManageInvoices,
		arg.CanManageEmployees,
		arg.CanManageCompanySettings,
		arg.CanManageBankAccounts,
		arg.CanManageWallets,
		arg.Permissions,
		arg.IsActive,
		arg.CompanyID,
		arg.UserID,
	)
	var i CompanyUsers
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.UserID,
		&i.Role,
		&i.Department,
		&i.JobTitle,
		&i.IsAdministrator,
		&i.CanManagePayroll,
		&i.CanManageInvoices,
		&i.CanManageEmployees,
		&i.CanManageCompanySettings,
		&i.CanManageBankAccounts,
		&i.CanManageWallets,
		&i.Permissions,
		&i.IsActive,
		&i.AddedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
