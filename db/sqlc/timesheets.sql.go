// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: timesheets.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createTimesheet = `-- name: CreateTimesheet :one
INSERT INTO timesheets (
  id,
  company_id,
  employee_id,
  period_id,
  status,
  total_hours,
  billable_hours,
  overtime_hours,
  hourly_rate,
  rate_currency,
  total_amount,
  submitted_at,
  approved_at,
  approved_by,
  rejection_reason,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  COALESCE($5, 'draft'),
  COALESCE($6, 0),
  COALESCE($7, 0),
  COALESCE($8, 0),
  $9,
  $10,
  COALESCE($11, 0),
  $12,
  $13,
  $14,
  $15,
  COALESCE($16, NOW()),
  COALESCE($17, NOW())
) RETURNING id, company_id, employee_id, period_id, status, total_hours, billable_hours, overtime_hours, hourly_rate, rate_currency, total_amount, submitted_at, approved_at, approved_by, rejection_reason, created_at, updated_at
`

type CreateTimesheetParams struct {
	ID              interface{}        `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          interface{}        `json:"status"`
	TotalHours      interface{}        `json:"total_hours"`
	BillableHours   interface{}        `json:"billable_hours"`
	OvertimeHours   interface{}        `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     interface{}        `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       interface{}        `json:"created_at"`
	UpdatedAt       interface{}        `json:"updated_at"`
}

func (q *Queries) CreateTimesheet(ctx context.Context, arg CreateTimesheetParams) (Timesheets, error) {
	row := q.db.QueryRow(ctx, createTimesheet,
		arg.ID,
		arg.CompanyID,
		arg.EmployeeID,
		arg.PeriodID,
		arg.Status,
		arg.TotalHours,
		arg.BillableHours,
		arg.OvertimeHours,
		arg.HourlyRate,
		arg.RateCurrency,
		arg.TotalAmount,
		arg.SubmittedAt,
		arg.ApprovedAt,
		arg.ApprovedBy,
		arg.RejectionReason,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Timesheets
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.EmployeeID,
		&i.PeriodID,
		&i.Status,
		&i.TotalHours,
		&i.BillableHours,
		&i.OvertimeHours,
		&i.HourlyRate,
		&i.RateCurrency,
		&i.TotalAmount,
		&i.SubmittedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTimesheetEntry = `-- name: CreateTimesheetEntry :one
INSERT INTO timesheet_entries (
  id,
  timesheet_id,
  date,
  start_time,
  end_time,
  hours,
  is_billable,
  is_overtime,
  project,
  task,
  description,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  COALESCE($7, TRUE),
  COALESCE($8, FALSE),
  $9,
  $10,
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, timesheet_id, date, start_time, end_time, hours, is_billable, is_overtime, project, task, description, created_at, updated_at
`

type CreateTimesheetEntryParams struct {
	ID          interface{}     `json:"id"`
	TimesheetID uuid.UUID       `json:"timesheet_id"`
	Date        pgtype.Date     `json:"date"`
	StartTime   pgtype.Time     `json:"start_time"`
	EndTime     pgtype.Time     `json:"end_time"`
	Hours       decimal.Decimal `json:"hours"`
	IsBillable  interface{}     `json:"is_billable"`
	IsOvertime  interface{}     `json:"is_overtime"`
	Project     pgtype.Text     `json:"project"`
	Task        pgtype.Text     `json:"task"`
	Description pgtype.Text     `json:"description"`
	CreatedAt   interface{}     `json:"created_at"`
	UpdatedAt   interface{}     `json:"updated_at"`
}

func (q *Queries) CreateTimesheetEntry(ctx context.Context, arg CreateTimesheetEntryParams) (TimesheetEntries, error) {
	row := q.db.QueryRow(ctx, createTimesheetEntry,
		arg.ID,
		arg.TimesheetID,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
		arg.Hours,
		arg.IsBillable,
		arg.IsOvertime,
		arg.Project,
		arg.Task,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i TimesheetEntries
	err := row.Scan(
		&i.ID,
		&i.TimesheetID,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Hours,
		&i.IsBillable,
		&i.IsOvertime,
		&i.Project,
		&i.Task,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTimesheetEntry = `-- name: DeleteTimesheetEntry :exec
DELETE FROM timesheet_entries WHERE id = $1
`

func (q *Queries) DeleteTimesheetEntry(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTimesheetEntry, id)
	return err
}

const getCompanyTimesheetSummary = `-- name: GetCompanyTimesheetSummary :one
SELECT 
  COUNT(*) as total_timesheets,
  SUM(total_hours) as total_hours,
  SUM(billable_hours) as total_billable_hours,
  SUM(overtime_hours) as total_overtime_hours,
  SUM(total_amount) as total_amount
FROM timesheets 
WHERE company_id = $1
  AND ($2::date IS NULL OR created_at >= $2)
  AND ($3::date IS NULL OR created_at <= $3)
`

type GetCompanyTimesheetSummaryParams struct {
	CompanyID uuid.UUID   `json:"company_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type GetCompanyTimesheetSummaryRow struct {
	TotalTimesheets    int64 `json:"total_timesheets"`
	TotalHours         int64 `json:"total_hours"`
	TotalBillableHours int64 `json:"total_billable_hours"`
	TotalOvertimeHours int64 `json:"total_overtime_hours"`
	TotalAmount        int64 `json:"total_amount"`
}

func (q *Queries) GetCompanyTimesheetSummary(ctx context.Context, arg GetCompanyTimesheetSummaryParams) (GetCompanyTimesheetSummaryRow, error) {
	row := q.db.QueryRow(ctx, getCompanyTimesheetSummary, arg.CompanyID, arg.StartDate, arg.EndDate)
	var i GetCompanyTimesheetSummaryRow
	err := row.Scan(
		&i.TotalTimesheets,
		&i.TotalHours,
		&i.TotalBillableHours,
		&i.TotalOvertimeHours,
		&i.TotalAmount,
	)
	return i, err
}

const getCompanyTimesheets = `-- name: GetCompanyTimesheets :many
SELECT t.id, t.company_id, t.employee_id, t.period_id, t.status, t.total_hours, t.billable_hours, t.overtime_hours, t.hourly_rate, t.rate_currency, t.total_amount, t.submitted_at, t.approved_at, t.approved_by, t.rejection_reason, t.created_at, t.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name,
       pp.period_name, pp.start_date, pp.end_date
FROM timesheets t
JOIN company_employees ce ON t.employee_id = ce.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
LEFT JOIN payroll_periods pp ON t.period_id = pp.id
WHERE t.company_id = $1
ORDER BY t.created_at DESC
LIMIT $3 OFFSET $2
`

type GetCompanyTimesheetsParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetCompanyTimesheetsRow struct {
	ID              uuid.UUID          `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2    pgtype.Text        `json:"employee_id_2"`
	Position        pgtype.Text        `json:"position"`
	Email           pgtype.Text        `json:"email"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	PeriodName      pgtype.Text        `json:"period_name"`
	StartDate       pgtype.Date        `json:"start_date"`
	EndDate         pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetCompanyTimesheets(ctx context.Context, arg GetCompanyTimesheetsParams) ([]GetCompanyTimesheetsRow, error) {
	rows, err := q.db.Query(ctx, getCompanyTimesheets, arg.CompanyID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyTimesheetsRow{}
	for rows.Next() {
		var i GetCompanyTimesheetsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.EmployeeID,
			&i.PeriodID,
			&i.Status,
			&i.TotalHours,
			&i.BillableHours,
			&i.OvertimeHours,
			&i.HourlyRate,
			&i.RateCurrency,
			&i.TotalAmount,
			&i.SubmittedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.Position,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeTimesheetSummary = `-- name: GetEmployeeTimesheetSummary :one
SELECT 
  COUNT(*) as total_timesheets,
  SUM(total_hours) as total_hours,
  SUM(billable_hours) as total_billable_hours,
  SUM(overtime_hours) as total_overtime_hours,
  SUM(total_amount) as total_amount
FROM timesheets 
WHERE employee_id = $1
  AND ($2::date IS NULL OR created_at >= $2)
  AND ($3::date IS NULL OR created_at <= $3)
`

type GetEmployeeTimesheetSummaryParams struct {
	EmployeeID uuid.UUID   `json:"employee_id"`
	StartDate  pgtype.Date `json:"start_date"`
	EndDate    pgtype.Date `json:"end_date"`
}

type GetEmployeeTimesheetSummaryRow struct {
	TotalTimesheets    int64 `json:"total_timesheets"`
	TotalHours         int64 `json:"total_hours"`
	TotalBillableHours int64 `json:"total_billable_hours"`
	TotalOvertimeHours int64 `json:"total_overtime_hours"`
	TotalAmount        int64 `json:"total_amount"`
}

func (q *Queries) GetEmployeeTimesheetSummary(ctx context.Context, arg GetEmployeeTimesheetSummaryParams) (GetEmployeeTimesheetSummaryRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeTimesheetSummary, arg.EmployeeID, arg.StartDate, arg.EndDate)
	var i GetEmployeeTimesheetSummaryRow
	err := row.Scan(
		&i.TotalTimesheets,
		&i.TotalHours,
		&i.TotalBillableHours,
		&i.TotalOvertimeHours,
		&i.TotalAmount,
	)
	return i, err
}

const getTimesheetByID = `-- name: GetTimesheetByID :one
SELECT t.id, t.company_id, t.employee_id, t.period_id, t.status, t.total_hours, t.billable_hours, t.overtime_hours, t.hourly_rate, t.rate_currency, t.total_amount, t.submitted_at, t.approved_at, t.approved_by, t.rejection_reason, t.created_at, t.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name,
       pp.period_name, pp.start_date, pp.end_date
FROM timesheets t
JOIN company_employees ce ON t.employee_id = ce.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
LEFT JOIN payroll_periods pp ON t.period_id = pp.id
WHERE t.id = $1
`

type GetTimesheetByIDRow struct {
	ID              uuid.UUID          `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2    pgtype.Text        `json:"employee_id_2"`
	Position        pgtype.Text        `json:"position"`
	Email           pgtype.Text        `json:"email"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	PeriodName      pgtype.Text        `json:"period_name"`
	StartDate       pgtype.Date        `json:"start_date"`
	EndDate         pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetTimesheetByID(ctx context.Context, id uuid.UUID) (GetTimesheetByIDRow, error) {
	row := q.db.QueryRow(ctx, getTimesheetByID, id)
	var i GetTimesheetByIDRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.EmployeeID,
		&i.PeriodID,
		&i.Status,
		&i.TotalHours,
		&i.BillableHours,
		&i.OvertimeHours,
		&i.HourlyRate,
		&i.RateCurrency,
		&i.TotalAmount,
		&i.SubmittedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmployeeID_2,
		&i.Position,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.PeriodName,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getTimesheetEntries = `-- name: GetTimesheetEntries :many
SELECT id, timesheet_id, date, start_time, end_time, hours, is_billable, is_overtime, project, task, description, created_at, updated_at FROM timesheet_entries 
WHERE timesheet_id = $1
ORDER BY date, start_time
`

func (q *Queries) GetTimesheetEntries(ctx context.Context, timesheetID uuid.UUID) ([]TimesheetEntries, error) {
	rows, err := q.db.Query(ctx, getTimesheetEntries, timesheetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimesheetEntries{}
	for rows.Next() {
		var i TimesheetEntries
		if err := rows.Scan(
			&i.ID,
			&i.TimesheetID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.Hours,
			&i.IsBillable,
			&i.IsOvertime,
			&i.Project,
			&i.Task,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimesheetEntriesByDate = `-- name: GetTimesheetEntriesByDate :many
SELECT id, timesheet_id, date, start_time, end_time, hours, is_billable, is_overtime, project, task, description, created_at, updated_at FROM timesheet_entries 
WHERE timesheet_id = $1 
  AND date >= $2 
  AND date <= $3
ORDER BY date, start_time
`

type GetTimesheetEntriesByDateParams struct {
	TimesheetID uuid.UUID   `json:"timesheet_id"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
}

func (q *Queries) GetTimesheetEntriesByDate(ctx context.Context, arg GetTimesheetEntriesByDateParams) ([]TimesheetEntries, error) {
	rows, err := q.db.Query(ctx, getTimesheetEntriesByDate, arg.TimesheetID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimesheetEntries{}
	for rows.Next() {
		var i TimesheetEntries
		if err := rows.Scan(
			&i.ID,
			&i.TimesheetID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.Hours,
			&i.IsBillable,
			&i.IsOvertime,
			&i.Project,
			&i.Task,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimesheetProjects = `-- name: GetTimesheetProjects :many
SELECT DISTINCT project 
FROM timesheet_entries 
WHERE timesheet_id IN (
  SELECT id FROM timesheets WHERE company_id = $1
)
AND project IS NOT NULL
ORDER BY project
`

func (q *Queries) GetTimesheetProjects(ctx context.Context, companyID uuid.UUID) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getTimesheetProjects, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var project pgtype.Text
		if err := rows.Scan(&project); err != nil {
			return nil, err
		}
		items = append(items, project)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimesheetsByEmployee = `-- name: GetTimesheetsByEmployee :many
SELECT t.id, t.company_id, t.employee_id, t.period_id, t.status, t.total_hours, t.billable_hours, t.overtime_hours, t.hourly_rate, t.rate_currency, t.total_amount, t.submitted_at, t.approved_at, t.approved_by, t.rejection_reason, t.created_at, t.updated_at, 
       pp.period_name, pp.start_date, pp.end_date
FROM timesheets t
LEFT JOIN payroll_periods pp ON t.period_id = pp.id
WHERE t.employee_id = $1
ORDER BY t.created_at DESC
`

type GetTimesheetsByEmployeeRow struct {
	ID              uuid.UUID          `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	PeriodName      pgtype.Text        `json:"period_name"`
	StartDate       pgtype.Date        `json:"start_date"`
	EndDate         pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetTimesheetsByEmployee(ctx context.Context, employeeID uuid.UUID) ([]GetTimesheetsByEmployeeRow, error) {
	rows, err := q.db.Query(ctx, getTimesheetsByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimesheetsByEmployeeRow{}
	for rows.Next() {
		var i GetTimesheetsByEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.EmployeeID,
			&i.PeriodID,
			&i.Status,
			&i.TotalHours,
			&i.BillableHours,
			&i.OvertimeHours,
			&i.HourlyRate,
			&i.RateCurrency,
			&i.TotalAmount,
			&i.SubmittedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimesheetsByStatus = `-- name: GetTimesheetsByStatus :many
SELECT t.id, t.company_id, t.employee_id, t.period_id, t.status, t.total_hours, t.billable_hours, t.overtime_hours, t.hourly_rate, t.rate_currency, t.total_amount, t.submitted_at, t.approved_at, t.approved_by, t.rejection_reason, t.created_at, t.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name,
       pp.period_name, pp.start_date, pp.end_date
FROM timesheets t
JOIN company_employees ce ON t.employee_id = ce.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
LEFT JOIN payroll_periods pp ON t.period_id = pp.id
WHERE t.company_id = $1 AND t.status = $2
ORDER BY t.created_at DESC
`

type GetTimesheetsByStatusParams struct {
	CompanyID uuid.UUID   `json:"company_id"`
	Status    pgtype.Text `json:"status"`
}

type GetTimesheetsByStatusRow struct {
	ID              uuid.UUID          `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2    pgtype.Text        `json:"employee_id_2"`
	Position        pgtype.Text        `json:"position"`
	Email           pgtype.Text        `json:"email"`
	FirstName       pgtype.Text        `json:"first_name"`
	LastName        pgtype.Text        `json:"last_name"`
	PeriodName      pgtype.Text        `json:"period_name"`
	StartDate       pgtype.Date        `json:"start_date"`
	EndDate         pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetTimesheetsByStatus(ctx context.Context, arg GetTimesheetsByStatusParams) ([]GetTimesheetsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getTimesheetsByStatus, arg.CompanyID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimesheetsByStatusRow{}
	for rows.Next() {
		var i GetTimesheetsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.EmployeeID,
			&i.PeriodID,
			&i.Status,
			&i.TotalHours,
			&i.BillableHours,
			&i.OvertimeHours,
			&i.HourlyRate,
			&i.RateCurrency,
			&i.TotalAmount,
			&i.SubmittedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.Position,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTimesheets = `-- name: GetUserTimesheets :many
SELECT t.id, t.company_id, t.employee_id, t.period_id, t.status, t.total_hours, t.billable_hours, t.overtime_hours, t.hourly_rate, t.rate_currency, t.total_amount, t.submitted_at, t.approved_at, t.approved_by, t.rejection_reason, t.created_at, t.updated_at, 
       ce.employee_id,
       c.company_name,
       pp.period_name, pp.start_date, pp.end_date
FROM timesheets t
JOIN company_employees ce ON t.employee_id = ce.id
JOIN companies c ON t.company_id = c.id
LEFT JOIN payroll_periods pp ON t.period_id = pp.id
WHERE ce.user_id = $1
ORDER BY t.created_at DESC
LIMIT $3 OFFSET $2
`

type GetUserTimesheetsParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetUserTimesheetsRow struct {
	ID              uuid.UUID          `json:"id"`
	CompanyID       uuid.UUID          `json:"company_id"`
	EmployeeID      uuid.UUID          `json:"employee_id"`
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2    pgtype.Text        `json:"employee_id_2"`
	CompanyName     string             `json:"company_name"`
	PeriodName      pgtype.Text        `json:"period_name"`
	StartDate       pgtype.Date        `json:"start_date"`
	EndDate         pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetUserTimesheets(ctx context.Context, arg GetUserTimesheetsParams) ([]GetUserTimesheetsRow, error) {
	rows, err := q.db.Query(ctx, getUserTimesheets, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTimesheetsRow{}
	for rows.Next() {
		var i GetUserTimesheetsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.EmployeeID,
			&i.PeriodID,
			&i.Status,
			&i.TotalHours,
			&i.BillableHours,
			&i.OvertimeHours,
			&i.HourlyRate,
			&i.RateCurrency,
			&i.TotalAmount,
			&i.SubmittedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.RejectionReason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.CompanyName,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTimesheet = `-- name: UpdateTimesheet :one
UPDATE timesheets SET
  period_id = COALESCE($1, period_id),
  status = COALESCE($2, status),
  total_hours = COALESCE($3, total_hours),
  billable_hours = COALESCE($4, billable_hours),
  overtime_hours = COALESCE($5, overtime_hours),
  hourly_rate = COALESCE($6, hourly_rate),
  rate_currency = COALESCE($7, rate_currency),
  total_amount = COALESCE($8, total_amount),
  submitted_at = COALESCE($9, submitted_at),
  approved_at = COALESCE($10, approved_at),
  approved_by = COALESCE($11, approved_by),
  rejection_reason = COALESCE($12, rejection_reason),
  updated_at = NOW()
WHERE id = $13
RETURNING id, company_id, employee_id, period_id, status, total_hours, billable_hours, overtime_hours, hourly_rate, rate_currency, total_amount, submitted_at, approved_at, approved_by, rejection_reason, created_at, updated_at
`

type UpdateTimesheetParams struct {
	PeriodID        pgtype.UUID        `json:"period_id"`
	Status          pgtype.Text        `json:"status"`
	TotalHours      pgtype.Numeric     `json:"total_hours"`
	BillableHours   pgtype.Numeric     `json:"billable_hours"`
	OvertimeHours   pgtype.Numeric     `json:"overtime_hours"`
	HourlyRate      pgtype.Numeric     `json:"hourly_rate"`
	RateCurrency    pgtype.Text        `json:"rate_currency"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	SubmittedAt     pgtype.Timestamptz `json:"submitted_at"`
	ApprovedAt      pgtype.Timestamptz `json:"approved_at"`
	ApprovedBy      pgtype.UUID        `json:"approved_by"`
	RejectionReason pgtype.Text        `json:"rejection_reason"`
	ID              uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateTimesheet(ctx context.Context, arg UpdateTimesheetParams) (Timesheets, error) {
	row := q.db.QueryRow(ctx, updateTimesheet,
		arg.PeriodID,
		arg.Status,
		arg.TotalHours,
		arg.BillableHours,
		arg.OvertimeHours,
		arg.HourlyRate,
		arg.RateCurrency,
		arg.TotalAmount,
		arg.SubmittedAt,
		arg.ApprovedAt,
		arg.ApprovedBy,
		arg.RejectionReason,
		arg.ID,
	)
	var i Timesheets
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.EmployeeID,
		&i.PeriodID,
		&i.Status,
		&i.TotalHours,
		&i.BillableHours,
		&i.OvertimeHours,
		&i.HourlyRate,
		&i.RateCurrency,
		&i.TotalAmount,
		&i.SubmittedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.RejectionReason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTimesheetEntry = `-- name: UpdateTimesheetEntry :one
UPDATE timesheet_entries SET
  date = COALESCE($1, date),
  start_time = COALESCE($2, start_time),
  end_time = COALESCE($3, end_time),
  hours = COALESCE($4, hours),
  is_billable = COALESCE($5, is_billable),
  is_overtime = COALESCE($6, is_overtime),
  project = COALESCE($7, project),
  task = COALESCE($8, task),
  description = COALESCE($9, description),
  updated_at = NOW()
WHERE id = $10
RETURNING id, timesheet_id, date, start_time, end_time, hours, is_billable, is_overtime, project, task, description, created_at, updated_at
`

type UpdateTimesheetEntryParams struct {
	Date        pgtype.Date     `json:"date"`
	StartTime   pgtype.Time     `json:"start_time"`
	EndTime     pgtype.Time     `json:"end_time"`
	Hours       decimal.Decimal `json:"hours"`
	IsBillable  pgtype.Bool     `json:"is_billable"`
	IsOvertime  pgtype.Bool     `json:"is_overtime"`
	Project     pgtype.Text     `json:"project"`
	Task        pgtype.Text     `json:"task"`
	Description pgtype.Text     `json:"description"`
	ID          uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateTimesheetEntry(ctx context.Context, arg UpdateTimesheetEntryParams) (TimesheetEntries, error) {
	row := q.db.QueryRow(ctx, updateTimesheetEntry,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
		arg.Hours,
		arg.IsBillable,
		arg.IsOvertime,
		arg.Project,
		arg.Task,
		arg.Description,
		arg.ID,
	)
	var i TimesheetEntries
	err := row.Scan(
		&i.ID,
		&i.TimesheetID,
		&i.Date,
		&i.StartTime,
		&i.EndTime,
		&i.Hours,
		&i.IsBillable,
		&i.IsOvertime,
		&i.Project,
		&i.Task,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
