// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: compliance.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCompanyCountryKYBStatus = `-- name: CreateCompanyCountryKYBStatus :one
INSERT INTO company_country_kyb_status (
  id,
  company_id,
  country_id,
  verification_status,
  verification_level,
  verification_date,
  expiry_date,
  rejection_reason,
  notes,
  risk_rating,
  restricted_features,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  COALESCE($4, 'pending'),
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, company_id, country_id, verification_status, verification_level, verification_date, expiry_date, rejection_reason, notes, risk_rating, restricted_features, created_at, updated_at
`

type CreateCompanyCountryKYBStatusParams struct {
	ID                 interface{}        `json:"id"`
	CompanyID          uuid.UUID          `json:"company_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	VerificationStatus interface{}        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CreatedAt          interface{}        `json:"created_at"`
	UpdatedAt          interface{}        `json:"updated_at"`
}

func (q *Queries) CreateCompanyCountryKYBStatus(ctx context.Context, arg CreateCompanyCountryKYBStatusParams) (CompanyCountryKybStatus, error) {
	row := q.db.QueryRow(ctx, createCompanyCountryKYBStatus,
		arg.ID,
		arg.CompanyID,
		arg.CountryID,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationDate,
		arg.ExpiryDate,
		arg.RejectionReason,
		arg.Notes,
		arg.RiskRating,
		arg.RestrictedFeatures,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CompanyCountryKybStatus
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createKYBDocument = `-- name: CreateKYBDocument :one
INSERT INTO kyb_documents (
  id,
  company_id,
  country_id,
  document_type,
  document_number,
  document_country,
  issue_date,
  expiry_date,
  document_url,
  ipfs_hash,
  verification_status,
  verification_level,
  verification_notes,
  verified_by,
  verified_at,
  rejection_reason,
  metadata,
  meets_requirements,
  requirement_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  COALESCE($11, 'pending'),
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  COALESCE($18, FALSE),
  $19,
  COALESCE($20, NOW()),
  COALESCE($21, NOW())
) RETURNING id, company_id, country_id, document_type, document_number, document_country, issue_date, expiry_date, document_url, ipfs_hash, verification_status, verification_level, verification_notes, verified_by, verified_at, rejection_reason, metadata, meets_requirements, requirement_id, created_at, updated_at
`

type CreateKYBDocumentParams struct {
	ID                 interface{}        `json:"id"`
	CompanyID          uuid.UUID          `json:"company_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	DocumentType       string             `json:"document_type"`
	DocumentNumber     pgtype.Text        `json:"document_number"`
	DocumentCountry    pgtype.Text        `json:"document_country"`
	IssueDate          pgtype.Date        `json:"issue_date"`
	ExpiryDate         pgtype.Date        `json:"expiry_date"`
	DocumentUrl        pgtype.Text        `json:"document_url"`
	IpfsHash           pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus interface{}        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationNotes  pgtype.Text        `json:"verification_notes"`
	VerifiedBy         pgtype.UUID        `json:"verified_by"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Metadata           []byte             `json:"metadata"`
	MeetsRequirements  interface{}        `json:"meets_requirements"`
	RequirementID      pgtype.UUID        `json:"requirement_id"`
	CreatedAt          interface{}        `json:"created_at"`
	UpdatedAt          interface{}        `json:"updated_at"`
}

func (q *Queries) CreateKYBDocument(ctx context.Context, arg CreateKYBDocumentParams) (KybDocuments, error) {
	row := q.db.QueryRow(ctx, createKYBDocument,
		arg.ID,
		arg.CompanyID,
		arg.CountryID,
		arg.DocumentType,
		arg.DocumentNumber,
		arg.DocumentCountry,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.DocumentUrl,
		arg.IpfsHash,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationNotes,
		arg.VerifiedBy,
		arg.VerifiedAt,
		arg.RejectionReason,
		arg.Metadata,
		arg.MeetsRequirements,
		arg.RequirementID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i KybDocuments
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CountryID,
		&i.DocumentType,
		&i.DocumentNumber,
		&i.DocumentCountry,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.DocumentUrl,
		&i.IpfsHash,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationNotes,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.RejectionReason,
		&i.Metadata,
		&i.MeetsRequirements,
		&i.RequirementID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createKYCDocument = `-- name: CreateKYCDocument :one
INSERT INTO kyc_documents (
  id,
  user_id,
  country_id,
  document_type,
  document_number,
  document_country,
  issue_date,
  expiry_date,
  document_url,
  ipfs_hash,
  verification_status,
  verification_level,
  verification_notes,
  verified_by,
  verified_at,
  rejection_reason,
  metadata,
  meets_requirements,
  requirement_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  COALESCE($11, 'pending'),
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  COALESCE($18, FALSE),
  $19,
  COALESCE($20, NOW()),
  COALESCE($21, NOW())
) RETURNING id, user_id, country_id, document_type, document_number, document_country, issue_date, expiry_date, document_url, ipfs_hash, verification_status, verification_level, verification_notes, verified_by, verified_at, rejection_reason, metadata, meets_requirements, requirement_id, created_at, updated_at
`

type CreateKYCDocumentParams struct {
	ID                 interface{}        `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	DocumentType       string             `json:"document_type"`
	DocumentNumber     pgtype.Text        `json:"document_number"`
	DocumentCountry    pgtype.Text        `json:"document_country"`
	IssueDate          pgtype.Date        `json:"issue_date"`
	ExpiryDate         pgtype.Date        `json:"expiry_date"`
	DocumentUrl        pgtype.Text        `json:"document_url"`
	IpfsHash           pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus interface{}        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationNotes  pgtype.Text        `json:"verification_notes"`
	VerifiedBy         pgtype.UUID        `json:"verified_by"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Metadata           []byte             `json:"metadata"`
	MeetsRequirements  interface{}        `json:"meets_requirements"`
	RequirementID      pgtype.UUID        `json:"requirement_id"`
	CreatedAt          interface{}        `json:"created_at"`
	UpdatedAt          interface{}        `json:"updated_at"`
}

func (q *Queries) CreateKYCDocument(ctx context.Context, arg CreateKYCDocumentParams) (KycDocuments, error) {
	row := q.db.QueryRow(ctx, createKYCDocument,
		arg.ID,
		arg.UserID,
		arg.CountryID,
		arg.DocumentType,
		arg.DocumentNumber,
		arg.DocumentCountry,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.DocumentUrl,
		arg.IpfsHash,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationNotes,
		arg.VerifiedBy,
		arg.VerifiedAt,
		arg.RejectionReason,
		arg.Metadata,
		arg.MeetsRequirements,
		arg.RequirementID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i KycDocuments
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.DocumentType,
		&i.DocumentNumber,
		&i.DocumentCountry,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.DocumentUrl,
		&i.IpfsHash,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationNotes,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.RejectionReason,
		&i.Metadata,
		&i.MeetsRequirements,
		&i.RequirementID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSupportedCountry = `-- name: CreateSupportedCountry :one
INSERT INTO supported_countries (
  id,
  country_code,
  country_name,
  region,
  currency_code,
  currency_symbol,
  is_active,
  is_high_risk,
  requires_enhanced_kyc,
  requires_enhanced_kyb,
  timezone,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  COALESCE($7, TRUE),
  COALESCE($8, FALSE),
  COALESCE($9, FALSE),
  COALESCE($10, FALSE),
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, country_code, country_name, region, currency_code, currency_symbol, is_active, is_high_risk, requires_enhanced_kyc, requires_enhanced_kyb, timezone, created_at, updated_at
`

type CreateSupportedCountryParams struct {
	ID                  interface{} `json:"id"`
	CountryCode         string      `json:"country_code"`
	CountryName         string      `json:"country_name"`
	Region              pgtype.Text `json:"region"`
	CurrencyCode        pgtype.Text `json:"currency_code"`
	CurrencySymbol      pgtype.Text `json:"currency_symbol"`
	IsActive            interface{} `json:"is_active"`
	IsHighRisk          interface{} `json:"is_high_risk"`
	RequiresEnhancedKyc interface{} `json:"requires_enhanced_kyc"`
	RequiresEnhancedKyb interface{} `json:"requires_enhanced_kyb"`
	Timezone            pgtype.Text `json:"timezone"`
	CreatedAt           interface{} `json:"created_at"`
	UpdatedAt           interface{} `json:"updated_at"`
}

func (q *Queries) CreateSupportedCountry(ctx context.Context, arg CreateSupportedCountryParams) (SupportedCountries, error) {
	row := q.db.QueryRow(ctx, createSupportedCountry,
		arg.ID,
		arg.CountryCode,
		arg.CountryName,
		arg.Region,
		arg.CurrencyCode,
		arg.CurrencySymbol,
		arg.IsActive,
		arg.IsHighRisk,
		arg.RequiresEnhancedKyc,
		arg.RequiresEnhancedKyb,
		arg.Timezone,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SupportedCountries
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.CountryName,
		&i.Region,
		&i.CurrencyCode,
		&i.CurrencySymbol,
		&i.IsActive,
		&i.IsHighRisk,
		&i.RequiresEnhancedKyc,
		&i.RequiresEnhancedKyb,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserCountryKYCStatus = `-- name: CreateUserCountryKYCStatus :one
INSERT INTO user_country_kyc_status (
  id,
  user_id,
  country_id,
  verification_status,
  verification_level,
  verification_date,
  expiry_date,
  rejection_reason,
  notes,
  risk_rating,
  restricted_features,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  COALESCE($4, 'pending'),
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, user_id, country_id, verification_status, verification_level, verification_date, expiry_date, rejection_reason, notes, risk_rating, restricted_features, created_at, updated_at
`

type CreateUserCountryKYCStatusParams struct {
	ID                 interface{}        `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	VerificationStatus interface{}        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CreatedAt          interface{}        `json:"created_at"`
	UpdatedAt          interface{}        `json:"updated_at"`
}

func (q *Queries) CreateUserCountryKYCStatus(ctx context.Context, arg CreateUserCountryKYCStatusParams) (UserCountryKycStatus, error) {
	row := q.db.QueryRow(ctx, createUserCountryKYCStatus,
		arg.ID,
		arg.UserID,
		arg.CountryID,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationDate,
		arg.ExpiryDate,
		arg.RejectionReason,
		arg.Notes,
		arg.RiskRating,
		arg.RestrictedFeatures,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UserCountryKycStatus
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompanyKYBStatus = `-- name: GetCompanyKYBStatus :one
SELECT ckbs.id, ckbs.company_id, ckbs.country_id, ckbs.verification_status, ckbs.verification_level, ckbs.verification_date, ckbs.expiry_date, ckbs.rejection_reason, ckbs.notes, ckbs.risk_rating, ckbs.restricted_features, ckbs.created_at, ckbs.updated_at, sc.country_name
FROM company_country_kyb_status ckbs
JOIN supported_countries sc ON ckbs.country_id = sc.id
WHERE ckbs.company_id = $1 AND ckbs.country_id = $2
`

type GetCompanyKYBStatusParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	CountryID uuid.UUID `json:"country_id"`
}

type GetCompanyKYBStatusRow struct {
	ID                 uuid.UUID          `json:"id"`
	CompanyID          uuid.UUID          `json:"company_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	CountryName        string             `json:"country_name"`
}

func (q *Queries) GetCompanyKYBStatus(ctx context.Context, arg GetCompanyKYBStatusParams) (GetCompanyKYBStatusRow, error) {
	row := q.db.QueryRow(ctx, getCompanyKYBStatus, arg.CompanyID, arg.CountryID)
	var i GetCompanyKYBStatusRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CountryName,
	)
	return i, err
}

const getKYBCountryRequirements = `-- name: GetKYBCountryRequirements :many
SELECT id, country_id, document_type, business_type, is_required, requirement_description, acceptable_document_formats, verification_level, additional_attributes, is_active, created_at, updated_at FROM kyb_country_requirements 
WHERE country_id = $1 AND is_active = TRUE
ORDER BY document_type
`

func (q *Queries) GetKYBCountryRequirements(ctx context.Context, countryID uuid.UUID) ([]KybCountryRequirements, error) {
	rows, err := q.db.Query(ctx, getKYBCountryRequirements, countryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KybCountryRequirements{}
	for rows.Next() {
		var i KybCountryRequirements
		if err := rows.Scan(
			&i.ID,
			&i.CountryID,
			&i.DocumentType,
			&i.BusinessType,
			&i.IsRequired,
			&i.RequirementDescription,
			&i.AcceptableDocumentFormats,
			&i.VerificationLevel,
			&i.AdditionalAttributes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKYBDocumentsByCompany = `-- name: GetKYBDocumentsByCompany :many
SELECT kbd.id, kbd.company_id, kbd.country_id, kbd.document_type, kbd.document_number, kbd.document_country, kbd.issue_date, kbd.expiry_date, kbd.document_url, kbd.ipfs_hash, kbd.verification_status, kbd.verification_level, kbd.verification_notes, kbd.verified_by, kbd.verified_at, kbd.rejection_reason, kbd.metadata, kbd.meets_requirements, kbd.requirement_id, kbd.created_at, kbd.updated_at, sc.country_name, kbcr.document_type as required_document_type
FROM kyb_documents kbd
JOIN supported_countries sc ON kbd.country_id = sc.id
LEFT JOIN kyb_country_requirements kbcr ON kbd.requirement_id = kbcr.id
WHERE kbd.company_id = $1
ORDER BY kbd.created_at DESC
`

type GetKYBDocumentsByCompanyRow struct {
	ID                   uuid.UUID          `json:"id"`
	CompanyID            uuid.UUID          `json:"company_id"`
	CountryID            uuid.UUID          `json:"country_id"`
	DocumentType         string             `json:"document_type"`
	DocumentNumber       pgtype.Text        `json:"document_number"`
	DocumentCountry      pgtype.Text        `json:"document_country"`
	IssueDate            pgtype.Date        `json:"issue_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	DocumentUrl          pgtype.Text        `json:"document_url"`
	IpfsHash             pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus   pgtype.Text        `json:"verification_status"`
	VerificationLevel    pgtype.Text        `json:"verification_level"`
	VerificationNotes    pgtype.Text        `json:"verification_notes"`
	VerifiedBy           pgtype.UUID        `json:"verified_by"`
	VerifiedAt           pgtype.Timestamptz `json:"verified_at"`
	RejectionReason      pgtype.Text        `json:"rejection_reason"`
	Metadata             []byte             `json:"metadata"`
	MeetsRequirements    pgtype.Bool        `json:"meets_requirements"`
	RequirementID        pgtype.UUID        `json:"requirement_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CountryName          string             `json:"country_name"`
	RequiredDocumentType pgtype.Text        `json:"required_document_type"`
}

func (q *Queries) GetKYBDocumentsByCompany(ctx context.Context, companyID uuid.UUID) ([]GetKYBDocumentsByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getKYBDocumentsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetKYBDocumentsByCompanyRow{}
	for rows.Next() {
		var i GetKYBDocumentsByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.CountryID,
			&i.DocumentType,
			&i.DocumentNumber,
			&i.DocumentCountry,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.DocumentUrl,
			&i.IpfsHash,
			&i.VerificationStatus,
			&i.VerificationLevel,
			&i.VerificationNotes,
			&i.VerifiedBy,
			&i.VerifiedAt,
			&i.RejectionReason,
			&i.Metadata,
			&i.MeetsRequirements,
			&i.RequirementID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CountryName,
			&i.RequiredDocumentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKYCCountryRequirements = `-- name: GetKYCCountryRequirements :many
SELECT id, country_id, document_type, is_required, requirement_description, acceptable_document_formats, verification_level, additional_attributes, is_active, created_at, updated_at FROM kyc_country_requirements 
WHERE country_id = $1 AND is_active = TRUE
ORDER BY document_type
`

func (q *Queries) GetKYCCountryRequirements(ctx context.Context, countryID uuid.UUID) ([]KycCountryRequirements, error) {
	rows, err := q.db.Query(ctx, getKYCCountryRequirements, countryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KycCountryRequirements{}
	for rows.Next() {
		var i KycCountryRequirements
		if err := rows.Scan(
			&i.ID,
			&i.CountryID,
			&i.DocumentType,
			&i.IsRequired,
			&i.RequirementDescription,
			&i.AcceptableDocumentFormats,
			&i.VerificationLevel,
			&i.AdditionalAttributes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKYCDocumentsByCountry = `-- name: GetKYCDocumentsByCountry :many
SELECT kd.id, kd.user_id, kd.country_id, kd.document_type, kd.document_number, kd.document_country, kd.issue_date, kd.expiry_date, kd.document_url, kd.ipfs_hash, kd.verification_status, kd.verification_level, kd.verification_notes, kd.verified_by, kd.verified_at, kd.rejection_reason, kd.metadata, kd.meets_requirements, kd.requirement_id, kd.created_at, kd.updated_at, sc.country_name, kcr.document_type as required_document_type
FROM kyc_documents kd
JOIN supported_countries sc ON kd.country_id = sc.id
LEFT JOIN kyc_country_requirements kcr ON kd.requirement_id = kcr.id
WHERE kd.user_id = $1 AND kd.country_id = $2
ORDER BY kd.created_at DESC
`

type GetKYCDocumentsByCountryParams struct {
	UserID    uuid.UUID `json:"user_id"`
	CountryID uuid.UUID `json:"country_id"`
}

type GetKYCDocumentsByCountryRow struct {
	ID                   uuid.UUID          `json:"id"`
	UserID               uuid.UUID          `json:"user_id"`
	CountryID            uuid.UUID          `json:"country_id"`
	DocumentType         string             `json:"document_type"`
	DocumentNumber       pgtype.Text        `json:"document_number"`
	DocumentCountry      pgtype.Text        `json:"document_country"`
	IssueDate            pgtype.Date        `json:"issue_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	DocumentUrl          pgtype.Text        `json:"document_url"`
	IpfsHash             pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus   pgtype.Text        `json:"verification_status"`
	VerificationLevel    pgtype.Text        `json:"verification_level"`
	VerificationNotes    pgtype.Text        `json:"verification_notes"`
	VerifiedBy           pgtype.UUID        `json:"verified_by"`
	VerifiedAt           pgtype.Timestamptz `json:"verified_at"`
	RejectionReason      pgtype.Text        `json:"rejection_reason"`
	Metadata             []byte             `json:"metadata"`
	MeetsRequirements    pgtype.Bool        `json:"meets_requirements"`
	RequirementID        pgtype.UUID        `json:"requirement_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CountryName          string             `json:"country_name"`
	RequiredDocumentType pgtype.Text        `json:"required_document_type"`
}

func (q *Queries) GetKYCDocumentsByCountry(ctx context.Context, arg GetKYCDocumentsByCountryParams) ([]GetKYCDocumentsByCountryRow, error) {
	rows, err := q.db.Query(ctx, getKYCDocumentsByCountry, arg.UserID, arg.CountryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetKYCDocumentsByCountryRow{}
	for rows.Next() {
		var i GetKYCDocumentsByCountryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CountryID,
			&i.DocumentType,
			&i.DocumentNumber,
			&i.DocumentCountry,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.DocumentUrl,
			&i.IpfsHash,
			&i.VerificationStatus,
			&i.VerificationLevel,
			&i.VerificationNotes,
			&i.VerifiedBy,
			&i.VerifiedAt,
			&i.RejectionReason,
			&i.Metadata,
			&i.MeetsRequirements,
			&i.RequirementID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CountryName,
			&i.RequiredDocumentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKYCDocumentsByUser = `-- name: GetKYCDocumentsByUser :many
SELECT kd.id, kd.user_id, kd.country_id, kd.document_type, kd.document_number, kd.document_country, kd.issue_date, kd.expiry_date, kd.document_url, kd.ipfs_hash, kd.verification_status, kd.verification_level, kd.verification_notes, kd.verified_by, kd.verified_at, kd.rejection_reason, kd.metadata, kd.meets_requirements, kd.requirement_id, kd.created_at, kd.updated_at, sc.country_name, kcr.document_type as required_document_type
FROM kyc_documents kd
JOIN supported_countries sc ON kd.country_id = sc.id
LEFT JOIN kyc_country_requirements kcr ON kd.requirement_id = kcr.id
WHERE kd.user_id = $1
ORDER BY kd.created_at DESC
`

type GetKYCDocumentsByUserRow struct {
	ID                   uuid.UUID          `json:"id"`
	UserID               uuid.UUID          `json:"user_id"`
	CountryID            uuid.UUID          `json:"country_id"`
	DocumentType         string             `json:"document_type"`
	DocumentNumber       pgtype.Text        `json:"document_number"`
	DocumentCountry      pgtype.Text        `json:"document_country"`
	IssueDate            pgtype.Date        `json:"issue_date"`
	ExpiryDate           pgtype.Date        `json:"expiry_date"`
	DocumentUrl          pgtype.Text        `json:"document_url"`
	IpfsHash             pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus   pgtype.Text        `json:"verification_status"`
	VerificationLevel    pgtype.Text        `json:"verification_level"`
	VerificationNotes    pgtype.Text        `json:"verification_notes"`
	VerifiedBy           pgtype.UUID        `json:"verified_by"`
	VerifiedAt           pgtype.Timestamptz `json:"verified_at"`
	RejectionReason      pgtype.Text        `json:"rejection_reason"`
	Metadata             []byte             `json:"metadata"`
	MeetsRequirements    pgtype.Bool        `json:"meets_requirements"`
	RequirementID        pgtype.UUID        `json:"requirement_id"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	CountryName          string             `json:"country_name"`
	RequiredDocumentType pgtype.Text        `json:"required_document_type"`
}

func (q *Queries) GetKYCDocumentsByUser(ctx context.Context, userID uuid.UUID) ([]GetKYCDocumentsByUserRow, error) {
	rows, err := q.db.Query(ctx, getKYCDocumentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetKYCDocumentsByUserRow{}
	for rows.Next() {
		var i GetKYCDocumentsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CountryID,
			&i.DocumentType,
			&i.DocumentNumber,
			&i.DocumentCountry,
			&i.IssueDate,
			&i.ExpiryDate,
			&i.DocumentUrl,
			&i.IpfsHash,
			&i.VerificationStatus,
			&i.VerificationLevel,
			&i.VerificationNotes,
			&i.VerifiedBy,
			&i.VerifiedAt,
			&i.RejectionReason,
			&i.Metadata,
			&i.MeetsRequirements,
			&i.RequirementID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CountryName,
			&i.RequiredDocumentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupportedCountries = `-- name: GetSupportedCountries :many
SELECT id, country_code, country_name, region, currency_code, currency_symbol, is_active, is_high_risk, requires_enhanced_kyc, requires_enhanced_kyb, timezone, created_at, updated_at FROM supported_countries 
WHERE is_active = TRUE
ORDER BY country_name
`

func (q *Queries) GetSupportedCountries(ctx context.Context) ([]SupportedCountries, error) {
	rows, err := q.db.Query(ctx, getSupportedCountries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportedCountries{}
	for rows.Next() {
		var i SupportedCountries
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.CountryName,
			&i.Region,
			&i.CurrencyCode,
			&i.CurrencySymbol,
			&i.IsActive,
			&i.IsHighRisk,
			&i.RequiresEnhancedKyc,
			&i.RequiresEnhancedKyb,
			&i.Timezone,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupportedCountryByCode = `-- name: GetSupportedCountryByCode :one
SELECT id, country_code, country_name, region, currency_code, currency_symbol, is_active, is_high_risk, requires_enhanced_kyc, requires_enhanced_kyb, timezone, created_at, updated_at FROM supported_countries 
WHERE country_code = $1 AND is_active = TRUE
`

func (q *Queries) GetSupportedCountryByCode(ctx context.Context, countryCode string) (SupportedCountries, error) {
	row := q.db.QueryRow(ctx, getSupportedCountryByCode, countryCode)
	var i SupportedCountries
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.CountryName,
		&i.Region,
		&i.CurrencyCode,
		&i.CurrencySymbol,
		&i.IsActive,
		&i.IsHighRisk,
		&i.RequiresEnhancedKyc,
		&i.RequiresEnhancedKyb,
		&i.Timezone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserKYCStatus = `-- name: GetUserKYCStatus :one
SELECT ukcs.id, ukcs.user_id, ukcs.country_id, ukcs.verification_status, ukcs.verification_level, ukcs.verification_date, ukcs.expiry_date, ukcs.rejection_reason, ukcs.notes, ukcs.risk_rating, ukcs.restricted_features, ukcs.created_at, ukcs.updated_at, sc.country_name
FROM user_country_kyc_status ukcs
JOIN supported_countries sc ON ukcs.country_id = sc.id
WHERE ukcs.user_id = $1 AND ukcs.country_id = $2
`

type GetUserKYCStatusParams struct {
	UserID    uuid.UUID `json:"user_id"`
	CountryID uuid.UUID `json:"country_id"`
}

type GetUserKYCStatusRow struct {
	ID                 uuid.UUID          `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	CountryName        string             `json:"country_name"`
}

func (q *Queries) GetUserKYCStatus(ctx context.Context, arg GetUserKYCStatusParams) (GetUserKYCStatusRow, error) {
	row := q.db.QueryRow(ctx, getUserKYCStatus, arg.UserID, arg.CountryID)
	var i GetUserKYCStatusRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CountryName,
	)
	return i, err
}

const getUserKYCStatusByCountryCode = `-- name: GetUserKYCStatusByCountryCode :one
SELECT ukcs.id, ukcs.user_id, ukcs.country_id, ukcs.verification_status, ukcs.verification_level, ukcs.verification_date, ukcs.expiry_date, ukcs.rejection_reason, ukcs.notes, ukcs.risk_rating, ukcs.restricted_features, ukcs.created_at, ukcs.updated_at, sc.country_name
FROM user_country_kyc_status ukcs
JOIN supported_countries sc ON ukcs.country_id = sc.id
WHERE ukcs.user_id = $1 AND sc.country_code = $2
`

type GetUserKYCStatusByCountryCodeParams struct {
	UserID      uuid.UUID `json:"user_id"`
	CountryCode string    `json:"country_code"`
}

type GetUserKYCStatusByCountryCodeRow struct {
	ID                 uuid.UUID          `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	CountryID          uuid.UUID          `json:"country_id"`
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	CountryName        string             `json:"country_name"`
}

func (q *Queries) GetUserKYCStatusByCountryCode(ctx context.Context, arg GetUserKYCStatusByCountryCodeParams) (GetUserKYCStatusByCountryCodeRow, error) {
	row := q.db.QueryRow(ctx, getUserKYCStatusByCountryCode, arg.UserID, arg.CountryCode)
	var i GetUserKYCStatusByCountryCodeRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CountryName,
	)
	return i, err
}

const updateCompanyKYBStatus = `-- name: UpdateCompanyKYBStatus :one
UPDATE company_country_kyb_status SET
  verification_status = COALESCE($1, verification_status),
  verification_level = COALESCE($2, verification_level),
  verification_date = COALESCE($3, verification_date),
  expiry_date = COALESCE($4, expiry_date),
  rejection_reason = COALESCE($5, rejection_reason),
  notes = COALESCE($6, notes),
  risk_rating = COALESCE($7, risk_rating),
  restricted_features = COALESCE($8, restricted_features),
  updated_at = NOW()
WHERE company_id = $9 AND country_id = $10
RETURNING id, company_id, country_id, verification_status, verification_level, verification_date, expiry_date, rejection_reason, notes, risk_rating, restricted_features, created_at, updated_at
`

type UpdateCompanyKYBStatusParams struct {
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	CompanyID          uuid.UUID          `json:"company_id"`
	CountryID          uuid.UUID          `json:"country_id"`
}

func (q *Queries) UpdateCompanyKYBStatus(ctx context.Context, arg UpdateCompanyKYBStatusParams) (CompanyCountryKybStatus, error) {
	row := q.db.QueryRow(ctx, updateCompanyKYBStatus,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationDate,
		arg.ExpiryDate,
		arg.RejectionReason,
		arg.Notes,
		arg.RiskRating,
		arg.RestrictedFeatures,
		arg.CompanyID,
		arg.CountryID,
	)
	var i CompanyCountryKybStatus
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateKYCDocument = `-- name: UpdateKYCDocument :one
UPDATE kyc_documents SET
  document_number = COALESCE($1, document_number),
  document_country = COALESCE($2, document_country),
  issue_date = COALESCE($3, issue_date),
  expiry_date = COALESCE($4, expiry_date),
  document_url = COALESCE($5, document_url),
  ipfs_hash = COALESCE($6, ipfs_hash),
  verification_status = COALESCE($7, verification_status),
  verification_level = COALESCE($8, verification_level),
  verification_notes = COALESCE($9, verification_notes),
  verified_by = COALESCE($10, verified_by),
  verified_at = COALESCE($11, verified_at),
  rejection_reason = COALESCE($12, rejection_reason),
  metadata = COALESCE($13, metadata),
  meets_requirements = COALESCE($14, meets_requirements),
  updated_at = NOW()
WHERE id = $15
RETURNING id, user_id, country_id, document_type, document_number, document_country, issue_date, expiry_date, document_url, ipfs_hash, verification_status, verification_level, verification_notes, verified_by, verified_at, rejection_reason, metadata, meets_requirements, requirement_id, created_at, updated_at
`

type UpdateKYCDocumentParams struct {
	DocumentNumber     pgtype.Text        `json:"document_number"`
	DocumentCountry    pgtype.Text        `json:"document_country"`
	IssueDate          pgtype.Date        `json:"issue_date"`
	ExpiryDate         pgtype.Date        `json:"expiry_date"`
	DocumentUrl        pgtype.Text        `json:"document_url"`
	IpfsHash           pgtype.Text        `json:"ipfs_hash"`
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationNotes  pgtype.Text        `json:"verification_notes"`
	VerifiedBy         pgtype.UUID        `json:"verified_by"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Metadata           []byte             `json:"metadata"`
	MeetsRequirements  pgtype.Bool        `json:"meets_requirements"`
	ID                 uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateKYCDocument(ctx context.Context, arg UpdateKYCDocumentParams) (KycDocuments, error) {
	row := q.db.QueryRow(ctx, updateKYCDocument,
		arg.DocumentNumber,
		arg.DocumentCountry,
		arg.IssueDate,
		arg.ExpiryDate,
		arg.DocumentUrl,
		arg.IpfsHash,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationNotes,
		arg.VerifiedBy,
		arg.VerifiedAt,
		arg.RejectionReason,
		arg.Metadata,
		arg.MeetsRequirements,
		arg.ID,
	)
	var i KycDocuments
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.DocumentType,
		&i.DocumentNumber,
		&i.DocumentCountry,
		&i.IssueDate,
		&i.ExpiryDate,
		&i.DocumentUrl,
		&i.IpfsHash,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationNotes,
		&i.VerifiedBy,
		&i.VerifiedAt,
		&i.RejectionReason,
		&i.Metadata,
		&i.MeetsRequirements,
		&i.RequirementID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserKYCStatus = `-- name: UpdateUserKYCStatus :one
UPDATE user_country_kyc_status SET
  verification_status = COALESCE($1, verification_status),
  verification_level = COALESCE($2, verification_level),
  verification_date = COALESCE($3, verification_date),
  expiry_date = COALESCE($4, expiry_date),
  rejection_reason = COALESCE($5, rejection_reason),
  notes = COALESCE($6, notes),
  risk_rating = COALESCE($7, risk_rating),
  restricted_features = COALESCE($8, restricted_features),
  updated_at = NOW()
WHERE user_id = $9 AND country_id = $10
RETURNING id, user_id, country_id, verification_status, verification_level, verification_date, expiry_date, rejection_reason, notes, risk_rating, restricted_features, created_at, updated_at
`

type UpdateUserKYCStatusParams struct {
	VerificationStatus pgtype.Text        `json:"verification_status"`
	VerificationLevel  pgtype.Text        `json:"verification_level"`
	VerificationDate   pgtype.Timestamptz `json:"verification_date"`
	ExpiryDate         pgtype.Timestamptz `json:"expiry_date"`
	RejectionReason    pgtype.Text        `json:"rejection_reason"`
	Notes              pgtype.Text        `json:"notes"`
	RiskRating         pgtype.Text        `json:"risk_rating"`
	RestrictedFeatures []byte             `json:"restricted_features"`
	UserID             uuid.UUID          `json:"user_id"`
	CountryID          uuid.UUID          `json:"country_id"`
}

func (q *Queries) UpdateUserKYCStatus(ctx context.Context, arg UpdateUserKYCStatusParams) (UserCountryKycStatus, error) {
	row := q.db.QueryRow(ctx, updateUserKYCStatus,
		arg.VerificationStatus,
		arg.VerificationLevel,
		arg.VerificationDate,
		arg.ExpiryDate,
		arg.RejectionReason,
		arg.Notes,
		arg.RiskRating,
		arg.RestrictedFeatures,
		arg.UserID,
		arg.CountryID,
	)
	var i UserCountryKycStatus
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CountryID,
		&i.VerificationStatus,
		&i.VerificationLevel,
		&i.VerificationDate,
		&i.ExpiryDate,
		&i.RejectionReason,
		&i.Notes,
		&i.RiskRating,
		&i.RestrictedFeatures,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
