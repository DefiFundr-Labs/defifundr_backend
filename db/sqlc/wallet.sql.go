// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wallet.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSupportedNetwork = `-- name: CreateSupportedNetwork :one
INSERT INTO supported_networks (
  id,
  name,
  chain_id,
  network_type,
  currency_symbol,
  block_explorer_url,
  rpc_url,
  is_evm_compatible,
  is_active,
  transaction_speed,
  average_block_time,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  COALESCE($8, FALSE),
  COALESCE($9, TRUE),
  $10,
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at
`

type CreateSupportedNetworkParams struct {
	ID               interface{} `json:"id"`
	Name             string      `json:"name"`
	ChainID          int32       `json:"chain_id"`
	NetworkType      string      `json:"network_type"`
	CurrencySymbol   string      `json:"currency_symbol"`
	BlockExplorerUrl pgtype.Text `json:"block_explorer_url"`
	RpcUrl           pgtype.Text `json:"rpc_url"`
	IsEvmCompatible  interface{} `json:"is_evm_compatible"`
	IsActive         interface{} `json:"is_active"`
	TransactionSpeed pgtype.Text `json:"transaction_speed"`
	AverageBlockTime pgtype.Int4 `json:"average_block_time"`
	CreatedAt        interface{} `json:"created_at"`
	UpdatedAt        interface{} `json:"updated_at"`
}

func (q *Queries) CreateSupportedNetwork(ctx context.Context, arg CreateSupportedNetworkParams) (SupportedNetworks, error) {
	row := q.db.QueryRow(ctx, createSupportedNetwork,
		arg.ID,
		arg.Name,
		arg.ChainID,
		arg.NetworkType,
		arg.CurrencySymbol,
		arg.BlockExplorerUrl,
		arg.RpcUrl,
		arg.IsEvmCompatible,
		arg.IsActive,
		arg.TransactionSpeed,
		arg.AverageBlockTime,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SupportedNetworks
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ChainID,
		&i.NetworkType,
		&i.CurrencySymbol,
		&i.BlockExplorerUrl,
		&i.RpcUrl,
		&i.IsEvmCompatible,
		&i.IsActive,
		&i.TransactionSpeed,
		&i.AverageBlockTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSupportedToken = `-- name: CreateSupportedToken :one
INSERT INTO supported_tokens (
  id,
  network_id,
  name,
  symbol,
  decimals,
  contract_address,
  token_type,
  logo_url,
  is_stablecoin,
  is_active,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  COALESCE($5, 18),
  $6,
  $7,
  $8,
  COALESCE($9, FALSE),
  COALESCE($10, TRUE),
  COALESCE($11, NOW()),
  COALESCE($12, NOW())
) RETURNING id, network_id, name, symbol, decimals, contract_address, token_type, logo_url, is_stablecoin, is_active, created_at, updated_at
`

type CreateSupportedTokenParams struct {
	ID              interface{} `json:"id"`
	NetworkID       uuid.UUID   `json:"network_id"`
	Name            string      `json:"name"`
	Symbol          string      `json:"symbol"`
	Decimals        interface{} `json:"decimals"`
	ContractAddress pgtype.Text `json:"contract_address"`
	TokenType       string      `json:"token_type"`
	LogoUrl         pgtype.Text `json:"logo_url"`
	IsStablecoin    interface{} `json:"is_stablecoin"`
	IsActive        interface{} `json:"is_active"`
	CreatedAt       interface{} `json:"created_at"`
	UpdatedAt       interface{} `json:"updated_at"`
}

func (q *Queries) CreateSupportedToken(ctx context.Context, arg CreateSupportedTokenParams) (SupportedTokens, error) {
	row := q.db.QueryRow(ctx, createSupportedToken,
		arg.ID,
		arg.NetworkID,
		arg.Name,
		arg.Symbol,
		arg.Decimals,
		arg.ContractAddress,
		arg.TokenType,
		arg.LogoUrl,
		arg.IsStablecoin,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SupportedTokens
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.ContractAddress,
		&i.TokenType,
		&i.LogoUrl,
		&i.IsStablecoin,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWallet = `-- name: CreateUserWallet :one
INSERT INTO user_wallets (
  id,
  user_id,
  wallet_address,
  wallet_type,
  chain_id,
  is_default,
  is_verified,
  verification_method,
  verified_at,
  nickname,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, FALSE),
  COALESCE($7, FALSE),
  $8,
  $9,
  $10,
  COALESCE($11, NOW()),
  COALESCE($12, NOW())
) RETURNING id, user_id, wallet_address, wallet_type, chain_id, is_default, is_verified, verification_method, verified_at, nickname, created_at, updated_at
`

type CreateUserWalletParams struct {
	ID                 interface{}        `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	WalletAddress      string             `json:"wallet_address"`
	WalletType         string             `json:"wallet_type"`
	ChainID            int32              `json:"chain_id"`
	IsDefault          interface{}        `json:"is_default"`
	IsVerified         interface{}        `json:"is_verified"`
	VerificationMethod pgtype.Text        `json:"verification_method"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	Nickname           pgtype.Text        `json:"nickname"`
	CreatedAt          interface{}        `json:"created_at"`
	UpdatedAt          interface{}        `json:"updated_at"`
}

func (q *Queries) CreateUserWallet(ctx context.Context, arg CreateUserWalletParams) (UserWallets, error) {
	row := q.db.QueryRow(ctx, createUserWallet,
		arg.ID,
		arg.UserID,
		arg.WalletAddress,
		arg.WalletType,
		arg.ChainID,
		arg.IsDefault,
		arg.IsVerified,
		arg.VerificationMethod,
		arg.VerifiedAt,
		arg.Nickname,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UserWallets
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletAddress,
		&i.WalletType,
		&i.ChainID,
		&i.IsDefault,
		&i.IsVerified,
		&i.VerificationMethod,
		&i.VerifiedAt,
		&i.Nickname,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserWallet = `-- name: DeleteUserWallet :exec
DELETE FROM user_wallets WHERE id = $1
`

func (q *Queries) DeleteUserWallet(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserWallet, id)
	return err
}

const getMainnetNetworks = `-- name: GetMainnetNetworks :many
SELECT id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at FROM supported_networks 
WHERE network_type = 'mainnet' AND is_active = TRUE
ORDER BY chain_id
`

func (q *Queries) GetMainnetNetworks(ctx context.Context) ([]SupportedNetworks, error) {
	rows, err := q.db.Query(ctx, getMainnetNetworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportedNetworks{}
	for rows.Next() {
		var i SupportedNetworks
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ChainID,
			&i.NetworkType,
			&i.CurrencySymbol,
			&i.BlockExplorerUrl,
			&i.RpcUrl,
			&i.IsEvmCompatible,
			&i.IsActive,
			&i.TransactionSpeed,
			&i.AverageBlockTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStablecoinsByNetwork = `-- name: GetStablecoinsByNetwork :many
SELECT st.id, st.network_id, st.name, st.symbol, st.decimals, st.contract_address, st.token_type, st.logo_url, st.is_stablecoin, st.is_active, st.created_at, st.updated_at, sn.name as network_name, sn.chain_id
FROM supported_tokens st
JOIN supported_networks sn ON st.network_id = sn.id
WHERE sn.chain_id = $1 AND st.is_stablecoin = TRUE AND st.is_active = TRUE
ORDER BY st.symbol
`

type GetStablecoinsByNetworkRow struct {
	ID              uuid.UUID          `json:"id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	Name            string             `json:"name"`
	Symbol          string             `json:"symbol"`
	Decimals        int32              `json:"decimals"`
	ContractAddress pgtype.Text        `json:"contract_address"`
	TokenType       string             `json:"token_type"`
	LogoUrl         pgtype.Text        `json:"logo_url"`
	IsStablecoin    pgtype.Bool        `json:"is_stablecoin"`
	IsActive        pgtype.Bool        `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NetworkName     string             `json:"network_name"`
	ChainID         int32              `json:"chain_id"`
}

func (q *Queries) GetStablecoinsByNetwork(ctx context.Context, chainID int32) ([]GetStablecoinsByNetworkRow, error) {
	rows, err := q.db.Query(ctx, getStablecoinsByNetwork, chainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStablecoinsByNetworkRow{}
	for rows.Next() {
		var i GetStablecoinsByNetworkRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.ContractAddress,
			&i.TokenType,
			&i.LogoUrl,
			&i.IsStablecoin,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetworkName,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupportedNetworkByChainID = `-- name: GetSupportedNetworkByChainID :one
SELECT id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at FROM supported_networks 
WHERE chain_id = $1 AND is_active = TRUE
`

func (q *Queries) GetSupportedNetworkByChainID(ctx context.Context, chainID int32) (SupportedNetworks, error) {
	row := q.db.QueryRow(ctx, getSupportedNetworkByChainID, chainID)
	var i SupportedNetworks
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ChainID,
		&i.NetworkType,
		&i.CurrencySymbol,
		&i.BlockExplorerUrl,
		&i.RpcUrl,
		&i.IsEvmCompatible,
		&i.IsActive,
		&i.TransactionSpeed,
		&i.AverageBlockTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSupportedNetworks = `-- name: GetSupportedNetworks :many
SELECT id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at FROM supported_networks 
WHERE is_active = TRUE
ORDER BY chain_id
`

func (q *Queries) GetSupportedNetworks(ctx context.Context) ([]SupportedNetworks, error) {
	rows, err := q.db.Query(ctx, getSupportedNetworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportedNetworks{}
	for rows.Next() {
		var i SupportedNetworks
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ChainID,
			&i.NetworkType,
			&i.CurrencySymbol,
			&i.BlockExplorerUrl,
			&i.RpcUrl,
			&i.IsEvmCompatible,
			&i.IsActive,
			&i.TransactionSpeed,
			&i.AverageBlockTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestnetNetworks = `-- name: GetTestnetNetworks :many
SELECT id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at FROM supported_networks 
WHERE network_type = 'testnet' AND is_active = TRUE
ORDER BY chain_id
`

func (q *Queries) GetTestnetNetworks(ctx context.Context) ([]SupportedNetworks, error) {
	rows, err := q.db.Query(ctx, getTestnetNetworks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SupportedNetworks{}
	for rows.Next() {
		var i SupportedNetworks
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ChainID,
			&i.NetworkType,
			&i.CurrencySymbol,
			&i.BlockExplorerUrl,
			&i.RpcUrl,
			&i.IsEvmCompatible,
			&i.IsActive,
			&i.TransactionSpeed,
			&i.AverageBlockTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByContract = `-- name: GetTokenByContract :one
SELECT st.id, st.network_id, st.name, st.symbol, st.decimals, st.contract_address, st.token_type, st.logo_url, st.is_stablecoin, st.is_active, st.created_at, st.updated_at, sn.name as network_name, sn.chain_id
FROM supported_tokens st
JOIN supported_networks sn ON st.network_id = sn.id
WHERE st.contract_address = $1 AND sn.chain_id = $2
`

type GetTokenByContractParams struct {
	ContractAddress pgtype.Text `json:"contract_address"`
	ChainID         int32       `json:"chain_id"`
}

type GetTokenByContractRow struct {
	ID              uuid.UUID          `json:"id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	Name            string             `json:"name"`
	Symbol          string             `json:"symbol"`
	Decimals        int32              `json:"decimals"`
	ContractAddress pgtype.Text        `json:"contract_address"`
	TokenType       string             `json:"token_type"`
	LogoUrl         pgtype.Text        `json:"logo_url"`
	IsStablecoin    pgtype.Bool        `json:"is_stablecoin"`
	IsActive        pgtype.Bool        `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NetworkName     string             `json:"network_name"`
	ChainID         int32              `json:"chain_id"`
}

func (q *Queries) GetTokenByContract(ctx context.Context, arg GetTokenByContractParams) (GetTokenByContractRow, error) {
	row := q.db.QueryRow(ctx, getTokenByContract, arg.ContractAddress, arg.ChainID)
	var i GetTokenByContractRow
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.Name,
		&i.Symbol,
		&i.Decimals,
		&i.ContractAddress,
		&i.TokenType,
		&i.LogoUrl,
		&i.IsStablecoin,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.NetworkName,
		&i.ChainID,
	)
	return i, err
}

const getTokensByNetwork = `-- name: GetTokensByNetwork :many
SELECT st.id, st.network_id, st.name, st.symbol, st.decimals, st.contract_address, st.token_type, st.logo_url, st.is_stablecoin, st.is_active, st.created_at, st.updated_at, sn.name as network_name, sn.chain_id
FROM supported_tokens st
JOIN supported_networks sn ON st.network_id = sn.id
WHERE sn.chain_id = $1 AND st.is_active = TRUE
ORDER BY st.symbol
`

type GetTokensByNetworkRow struct {
	ID              uuid.UUID          `json:"id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	Name            string             `json:"name"`
	Symbol          string             `json:"symbol"`
	Decimals        int32              `json:"decimals"`
	ContractAddress pgtype.Text        `json:"contract_address"`
	TokenType       string             `json:"token_type"`
	LogoUrl         pgtype.Text        `json:"logo_url"`
	IsStablecoin    pgtype.Bool        `json:"is_stablecoin"`
	IsActive        pgtype.Bool        `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NetworkName     string             `json:"network_name"`
	ChainID         int32              `json:"chain_id"`
}

func (q *Queries) GetTokensByNetwork(ctx context.Context, chainID int32) ([]GetTokensByNetworkRow, error) {
	rows, err := q.db.Query(ctx, getTokensByNetwork, chainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokensByNetworkRow{}
	for rows.Next() {
		var i GetTokensByNetworkRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.ContractAddress,
			&i.TokenType,
			&i.LogoUrl,
			&i.IsStablecoin,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetworkName,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWalletsByNetwork = `-- name: GetUserWalletsByNetwork :many
SELECT uw.id, uw.user_id, uw.wallet_address, uw.wallet_type, uw.chain_id, uw.is_default, uw.is_verified, uw.verification_method, uw.verified_at, uw.nickname, uw.created_at, uw.updated_at, sn.name as network_name
FROM user_wallets uw
JOIN supported_networks sn ON uw.chain_id = sn.chain_id
WHERE uw.user_id = $1 AND uw.chain_id = $2
ORDER BY uw.is_default DESC, uw.created_at DESC
`

type GetUserWalletsByNetworkParams struct {
	UserID  uuid.UUID `json:"user_id"`
	ChainID int32     `json:"chain_id"`
}

type GetUserWalletsByNetworkRow struct {
	ID                 uuid.UUID          `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	WalletAddress      string             `json:"wallet_address"`
	WalletType         string             `json:"wallet_type"`
	ChainID            int32              `json:"chain_id"`
	IsDefault          pgtype.Bool        `json:"is_default"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	VerificationMethod pgtype.Text        `json:"verification_method"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	Nickname           pgtype.Text        `json:"nickname"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	NetworkName        string             `json:"network_name"`
}

func (q *Queries) GetUserWalletsByNetwork(ctx context.Context, arg GetUserWalletsByNetworkParams) ([]GetUserWalletsByNetworkRow, error) {
	rows, err := q.db.Query(ctx, getUserWalletsByNetwork, arg.UserID, arg.ChainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWalletsByNetworkRow{}
	for rows.Next() {
		var i GetUserWalletsByNetworkRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletAddress,
			&i.WalletType,
			&i.ChainID,
			&i.IsDefault,
			&i.IsVerified,
			&i.VerificationMethod,
			&i.VerifiedAt,
			&i.Nickname,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetworkName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWalletsByUser = `-- name: GetUserWalletsByUser :many
SELECT uw.id, uw.user_id, uw.wallet_address, uw.wallet_type, uw.chain_id, uw.is_default, uw.is_verified, uw.verification_method, uw.verified_at, uw.nickname, uw.created_at, uw.updated_at, sn.name as network_name
FROM user_wallets uw
JOIN supported_networks sn ON uw.chain_id = sn.chain_id
WHERE uw.user_id = $1
ORDER BY uw.is_default DESC, uw.created_at DESC
`

type GetUserWalletsByUserRow struct {
	ID                 uuid.UUID          `json:"id"`
	UserID             uuid.UUID          `json:"user_id"`
	WalletAddress      string             `json:"wallet_address"`
	WalletType         string             `json:"wallet_type"`
	ChainID            int32              `json:"chain_id"`
	IsDefault          pgtype.Bool        `json:"is_default"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	VerificationMethod pgtype.Text        `json:"verification_method"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	Nickname           pgtype.Text        `json:"nickname"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	NetworkName        string             `json:"network_name"`
}

func (q *Queries) GetUserWalletsByUser(ctx context.Context, userID uuid.UUID) ([]GetUserWalletsByUserRow, error) {
	rows, err := q.db.Query(ctx, getUserWalletsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserWalletsByUserRow{}
	for rows.Next() {
		var i GetUserWalletsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletAddress,
			&i.WalletType,
			&i.ChainID,
			&i.IsDefault,
			&i.IsVerified,
			&i.VerificationMethod,
			&i.VerifiedAt,
			&i.Nickname,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetworkName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTokens = `-- name: SearchTokens :many
SELECT st.id, st.network_id, st.name, st.symbol, st.decimals, st.contract_address, st.token_type, st.logo_url, st.is_stablecoin, st.is_active, st.created_at, st.updated_at, sn.name as network_name, sn.chain_id
FROM supported_tokens st
JOIN supported_networks sn ON st.network_id = sn.id
WHERE (st.name ILIKE '%' || $1 || '%' OR st.symbol ILIKE '%' || $1 || '%')
  AND st.is_active = TRUE
ORDER BY st.symbol
LIMIT $3 OFFSET $2
`

type SearchTokensParams struct {
	SearchTerm pgtype.Text `json:"search_term"`
	OffsetVal  int32       `json:"offset_val"`
	LimitVal   int32       `json:"limit_val"`
}

type SearchTokensRow struct {
	ID              uuid.UUID          `json:"id"`
	NetworkID       uuid.UUID          `json:"network_id"`
	Name            string             `json:"name"`
	Symbol          string             `json:"symbol"`
	Decimals        int32              `json:"decimals"`
	ContractAddress pgtype.Text        `json:"contract_address"`
	TokenType       string             `json:"token_type"`
	LogoUrl         pgtype.Text        `json:"logo_url"`
	IsStablecoin    pgtype.Bool        `json:"is_stablecoin"`
	IsActive        pgtype.Bool        `json:"is_active"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	NetworkName     string             `json:"network_name"`
	ChainID         int32              `json:"chain_id"`
}

func (q *Queries) SearchTokens(ctx context.Context, arg SearchTokensParams) ([]SearchTokensRow, error) {
	rows, err := q.db.Query(ctx, searchTokens, arg.SearchTerm, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTokensRow{}
	for rows.Next() {
		var i SearchTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.Name,
			&i.Symbol,
			&i.Decimals,
			&i.ContractAddress,
			&i.TokenType,
			&i.LogoUrl,
			&i.IsStablecoin,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NetworkName,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setUserWalletAsDefault = `-- name: SetUserWalletAsDefault :exec
UPDATE user_wallets SET
  is_default = CASE WHEN id = $1 THEN TRUE ELSE FALSE END,
  updated_at = NOW()
WHERE user_id = $2 AND chain_id = $3
`

type SetUserWalletAsDefaultParams struct {
	WalletID uuid.UUID `json:"wallet_id"`
	UserID   uuid.UUID `json:"user_id"`
	ChainID  int32     `json:"chain_id"`
}

func (q *Queries) SetUserWalletAsDefault(ctx context.Context, arg SetUserWalletAsDefaultParams) error {
	_, err := q.db.Exec(ctx, setUserWalletAsDefault, arg.WalletID, arg.UserID, arg.ChainID)
	return err
}

const updateNetworkStatus = `-- name: UpdateNetworkStatus :one
UPDATE supported_networks SET
  is_active = $1,
  updated_at = NOW()
WHERE chain_id = $2
RETURNING id, name, chain_id, network_type, currency_symbol, block_explorer_url, rpc_url, is_evm_compatible, is_active, transaction_speed, average_block_time, created_at, updated_at
`

type UpdateNetworkStatusParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	ChainID  int32       `json:"chain_id"`
}

func (q *Queries) UpdateNetworkStatus(ctx context.Context, arg UpdateNetworkStatusParams) (SupportedNetworks, error) {
	row := q.db.QueryRow(ctx, updateNetworkStatus, arg.IsActive, arg.ChainID)
	var i SupportedNetworks
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ChainID,
		&i.NetworkType,
		&i.CurrencySymbol,
		&i.BlockExplorerUrl,
		&i.RpcUrl,
		&i.IsEvmCompatible,
		&i.IsActive,
		&i.TransactionSpeed,
		&i.AverageBlockTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserWallet = `-- name: UpdateUserWallet :one
UPDATE user_wallets SET
  wallet_type = COALESCE($1, wallet_type),
  is_default = COALESCE($2, is_default),
  is_verified = COALESCE($3, is_verified),
  verification_method = COALESCE($4, verification_method),
  verified_at = COALESCE($5, verified_at),
  nickname = COALESCE($6, nickname),
  updated_at = NOW()
WHERE id = $7
RETURNING id, user_id, wallet_address, wallet_type, chain_id, is_default, is_verified, verification_method, verified_at, nickname, created_at, updated_at
`

type UpdateUserWalletParams struct {
	WalletType         string             `json:"wallet_type"`
	IsDefault          pgtype.Bool        `json:"is_default"`
	IsVerified         pgtype.Bool        `json:"is_verified"`
	VerificationMethod pgtype.Text        `json:"verification_method"`
	VerifiedAt         pgtype.Timestamptz `json:"verified_at"`
	Nickname           pgtype.Text        `json:"nickname"`
	ID                 uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateUserWallet(ctx context.Context, arg UpdateUserWalletParams) (UserWallets, error) {
	row := q.db.QueryRow(ctx, updateUserWallet,
		arg.WalletType,
		arg.IsDefault,
		arg.IsVerified,
		arg.VerificationMethod,
		arg.VerifiedAt,
		arg.Nickname,
		arg.ID,
	)
	var i UserWallets
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletAddress,
		&i.WalletType,
		&i.ChainID,
		&i.IsDefault,
		&i.IsVerified,
		&i.VerificationMethod,
		&i.VerifiedAt,
		&i.Nickname,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
