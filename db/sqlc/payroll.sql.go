// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: payroll.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createPayroll = `-- name: CreatePayroll :one
INSERT INTO payrolls (
  id,
  company_id,
  period_id,
  name,
  description,
  total_amount,
  base_currency,
  status,
  execution_type,
  scheduled_execution_time,
  executed_at,
  smart_contract_address,
  chain_id,
  transaction_hash,
  created_by,
  approved_by,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, 0),
  $7,
  COALESCE($8, 'draft'),
  COALESCE($9, 'manual'),
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  COALESCE($17, NOW()),
  COALESCE($18, NOW())
) RETURNING id, company_id, period_id, name, description, total_amount, base_currency, status, execution_type, scheduled_execution_time, executed_at, smart_contract_address, chain_id, transaction_hash, created_by, approved_by, created_at, updated_at
`

type CreatePayrollParams struct {
	ID                     interface{}        `json:"id"`
	CompanyID              uuid.UUID          `json:"company_id"`
	PeriodID               uuid.UUID          `json:"period_id"`
	Name                   string             `json:"name"`
	Description            pgtype.Text        `json:"description"`
	TotalAmount            interface{}        `json:"total_amount"`
	BaseCurrency           string             `json:"base_currency"`
	Status                 interface{}        `json:"status"`
	ExecutionType          interface{}        `json:"execution_type"`
	ScheduledExecutionTime pgtype.Timestamptz `json:"scheduled_execution_time"`
	ExecutedAt             pgtype.Timestamptz `json:"executed_at"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	CreatedBy              uuid.UUID          `json:"created_by"`
	ApprovedBy             pgtype.UUID        `json:"approved_by"`
	CreatedAt              interface{}        `json:"created_at"`
	UpdatedAt              interface{}        `json:"updated_at"`
}

func (q *Queries) CreatePayroll(ctx context.Context, arg CreatePayrollParams) (Payrolls, error) {
	row := q.db.QueryRow(ctx, createPayroll,
		arg.ID,
		arg.CompanyID,
		arg.PeriodID,
		arg.Name,
		arg.Description,
		arg.TotalAmount,
		arg.BaseCurrency,
		arg.Status,
		arg.ExecutionType,
		arg.ScheduledExecutionTime,
		arg.ExecutedAt,
		arg.SmartContractAddress,
		arg.ChainID,
		arg.TransactionHash,
		arg.CreatedBy,
		arg.ApprovedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Payrolls
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Name,
		&i.Description,
		&i.TotalAmount,
		&i.BaseCurrency,
		&i.Status,
		&i.ExecutionType,
		&i.ScheduledExecutionTime,
		&i.ExecutedAt,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.TransactionHash,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayrollItem = `-- name: CreatePayrollItem :one
INSERT INTO payroll_items (
  id,
  payroll_id,
  employee_id,
  base_amount,
  base_currency,
  payment_amount,
  payment_currency,
  exchange_rate,
  payment_method,
  payment_split,
  status,
  transaction_hash,
  recipient_wallet_address,
  recipient_bank_account_id,
  notes,
  timesheet_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  COALESCE($8, 1),
  $9,
  $10,
  COALESCE($11, 'pending'),
  $12,
  $13,
  $14,
  $15,
  $16,
  COALESCE($17, NOW()),
  COALESCE($18, NOW())
) RETURNING id, payroll_id, employee_id, base_amount, base_currency, payment_amount, payment_currency, exchange_rate, payment_method, payment_split, status, transaction_hash, recipient_wallet_address, recipient_bank_account_id, notes, timesheet_id, created_at, updated_at
`

type CreatePayrollItemParams struct {
	ID                     interface{}     `json:"id"`
	PayrollID              uuid.UUID       `json:"payroll_id"`
	EmployeeID             uuid.UUID       `json:"employee_id"`
	BaseAmount             decimal.Decimal `json:"base_amount"`
	BaseCurrency           string          `json:"base_currency"`
	PaymentAmount          decimal.Decimal `json:"payment_amount"`
	PaymentCurrency        string          `json:"payment_currency"`
	ExchangeRate           interface{}     `json:"exchange_rate"`
	PaymentMethod          string          `json:"payment_method"`
	PaymentSplit           []byte          `json:"payment_split"`
	Status                 interface{}     `json:"status"`
	TransactionHash        pgtype.Text     `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text     `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID     `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text     `json:"notes"`
	TimesheetID            pgtype.UUID     `json:"timesheet_id"`
	CreatedAt              interface{}     `json:"created_at"`
	UpdatedAt              interface{}     `json:"updated_at"`
}

func (q *Queries) CreatePayrollItem(ctx context.Context, arg CreatePayrollItemParams) (PayrollItems, error) {
	row := q.db.QueryRow(ctx, createPayrollItem,
		arg.ID,
		arg.PayrollID,
		arg.EmployeeID,
		arg.BaseAmount,
		arg.BaseCurrency,
		arg.PaymentAmount,
		arg.PaymentCurrency,
		arg.ExchangeRate,
		arg.PaymentMethod,
		arg.PaymentSplit,
		arg.Status,
		arg.TransactionHash,
		arg.RecipientWalletAddress,
		arg.RecipientBankAccountID,
		arg.Notes,
		arg.TimesheetID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PayrollItems
	err := row.Scan(
		&i.ID,
		&i.PayrollID,
		&i.EmployeeID,
		&i.BaseAmount,
		&i.BaseCurrency,
		&i.PaymentAmount,
		&i.PaymentCurrency,
		&i.ExchangeRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.Status,
		&i.TransactionHash,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.Notes,
		&i.TimesheetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayrollPeriod = `-- name: CreatePayrollPeriod :one
INSERT INTO payroll_periods (
  id,
  company_id,
  period_name,
  frequency,
  start_date,
  end_date,
  payment_date,
  status,
  is_recurring,
  next_period_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  COALESCE($8, 'draft'),
  COALESCE($9, FALSE),
  $10,
  COALESCE($11, NOW()),
  COALESCE($12, NOW())
) RETURNING id, company_id, period_name, frequency, start_date, end_date, payment_date, status, is_recurring, next_period_id, created_at, updated_at
`

type CreatePayrollPeriodParams struct {
	ID           interface{} `json:"id"`
	CompanyID    uuid.UUID   `json:"company_id"`
	PeriodName   string      `json:"period_name"`
	Frequency    string      `json:"frequency"`
	StartDate    pgtype.Date `json:"start_date"`
	EndDate      pgtype.Date `json:"end_date"`
	PaymentDate  pgtype.Date `json:"payment_date"`
	Status       interface{} `json:"status"`
	IsRecurring  interface{} `json:"is_recurring"`
	NextPeriodID pgtype.UUID `json:"next_period_id"`
	CreatedAt    interface{} `json:"created_at"`
	UpdatedAt    interface{} `json:"updated_at"`
}

func (q *Queries) CreatePayrollPeriod(ctx context.Context, arg CreatePayrollPeriodParams) (PayrollPeriods, error) {
	row := q.db.QueryRow(ctx, createPayrollPeriod,
		arg.ID,
		arg.CompanyID,
		arg.PeriodName,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.PaymentDate,
		arg.Status,
		arg.IsRecurring,
		arg.NextPeriodID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PayrollPeriods
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodName,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.PaymentDate,
		&i.Status,
		&i.IsRecurring,
		&i.NextPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivePayrollPeriods = `-- name: GetActivePayrollPeriods :many
SELECT id, company_id, period_name, frequency, start_date, end_date, payment_date, status, is_recurring, next_period_id, created_at, updated_at FROM payroll_periods 
WHERE company_id = $1 AND status = 'active'
ORDER BY start_date DESC
`

func (q *Queries) GetActivePayrollPeriods(ctx context.Context, companyID uuid.UUID) ([]PayrollPeriods, error) {
	rows, err := q.db.Query(ctx, getActivePayrollPeriods, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayrollPeriods{}
	for rows.Next() {
		var i PayrollPeriods
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PeriodName,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.PaymentDate,
			&i.Status,
			&i.IsRecurring,
			&i.NextPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollApprovalQueue = `-- name: GetPayrollApprovalQueue :many
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name,
       p.name as payroll_name
FROM payroll_items pi
JOIN company_employees ce ON pi.employee_id = ce.id
JOIN payrolls p ON pi.payroll_id = p.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE p.company_id = $1 AND pi.status = 'pending'
ORDER BY pi.created_at
`

type GetPayrollApprovalQueueRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2           pgtype.Text        `json:"employee_id_2"`
	Position               pgtype.Text        `json:"position"`
	Email                  pgtype.Text        `json:"email"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	PayrollName            string             `json:"payroll_name"`
}

func (q *Queries) GetPayrollApprovalQueue(ctx context.Context, companyID uuid.UUID) ([]GetPayrollApprovalQueueRow, error) {
	rows, err := q.db.Query(ctx, getPayrollApprovalQueue, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPayrollApprovalQueueRow{}
	for rows.Next() {
		var i GetPayrollApprovalQueueRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.BaseAmount,
			&i.BaseCurrency,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.ExchangeRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.Status,
			&i.TransactionHash,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.Notes,
			&i.TimesheetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.Position,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PayrollName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollByID = `-- name: GetPayrollByID :one
SELECT p.id, p.company_id, p.period_id, p.name, p.description, p.total_amount, p.base_currency, p.status, p.execution_type, p.scheduled_execution_time, p.executed_at, p.smart_contract_address, p.chain_id, p.transaction_hash, p.created_by, p.approved_by, p.created_at, p.updated_at, pp.period_name, pp.start_date, pp.end_date
FROM payrolls p
JOIN payroll_periods pp ON p.period_id = pp.id
WHERE p.id = $1
`

type GetPayrollByIDRow struct {
	ID                     uuid.UUID          `json:"id"`
	CompanyID              uuid.UUID          `json:"company_id"`
	PeriodID               uuid.UUID          `json:"period_id"`
	Name                   string             `json:"name"`
	Description            pgtype.Text        `json:"description"`
	TotalAmount            pgtype.Numeric     `json:"total_amount"`
	BaseCurrency           string             `json:"base_currency"`
	Status                 pgtype.Text        `json:"status"`
	ExecutionType          pgtype.Text        `json:"execution_type"`
	ScheduledExecutionTime pgtype.Timestamptz `json:"scheduled_execution_time"`
	ExecutedAt             pgtype.Timestamptz `json:"executed_at"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	CreatedBy              uuid.UUID          `json:"created_by"`
	ApprovedBy             pgtype.UUID        `json:"approved_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PeriodName             string             `json:"period_name"`
	StartDate              pgtype.Date        `json:"start_date"`
	EndDate                pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetPayrollByID(ctx context.Context, id uuid.UUID) (GetPayrollByIDRow, error) {
	row := q.db.QueryRow(ctx, getPayrollByID, id)
	var i GetPayrollByIDRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Name,
		&i.Description,
		&i.TotalAmount,
		&i.BaseCurrency,
		&i.Status,
		&i.ExecutionType,
		&i.ScheduledExecutionTime,
		&i.ExecutedAt,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.TransactionHash,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PeriodName,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const getPayrollItemByID = `-- name: GetPayrollItemByID :one
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM payroll_items pi
JOIN company_employees ce ON pi.employee_id = ce.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE pi.id = $1
`

type GetPayrollItemByIDRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2           pgtype.Text        `json:"employee_id_2"`
	Position               pgtype.Text        `json:"position"`
	Email                  pgtype.Text        `json:"email"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetPayrollItemByID(ctx context.Context, id uuid.UUID) (GetPayrollItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getPayrollItemByID, id)
	var i GetPayrollItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.PayrollID,
		&i.EmployeeID,
		&i.BaseAmount,
		&i.BaseCurrency,
		&i.PaymentAmount,
		&i.PaymentCurrency,
		&i.ExchangeRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.Status,
		&i.TransactionHash,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.Notes,
		&i.TimesheetID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmployeeID_2,
		&i.Position,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getPayrollItemsByEmployee = `-- name: GetPayrollItemsByEmployee :many
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, p.name as payroll_name, pp.period_name
FROM payroll_items pi
JOIN payrolls p ON pi.payroll_id = p.id
JOIN payroll_periods pp ON p.period_id = pp.id
WHERE pi.employee_id = $1
ORDER BY pi.created_at DESC
`

type GetPayrollItemsByEmployeeRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PayrollName            string             `json:"payroll_name"`
	PeriodName             string             `json:"period_name"`
}

func (q *Queries) GetPayrollItemsByEmployee(ctx context.Context, employeeID uuid.UUID) ([]GetPayrollItemsByEmployeeRow, error) {
	rows, err := q.db.Query(ctx, getPayrollItemsByEmployee, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPayrollItemsByEmployeeRow{}
	for rows.Next() {
		var i GetPayrollItemsByEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.BaseAmount,
			&i.BaseCurrency,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.ExchangeRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.Status,
			&i.TransactionHash,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.Notes,
			&i.TimesheetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayrollName,
			&i.PeriodName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollItemsByPayroll = `-- name: GetPayrollItemsByPayroll :many
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM payroll_items pi
JOIN company_employees ce ON pi.employee_id = ce.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE pi.payroll_id = $1
ORDER BY pi.created_at
`

type GetPayrollItemsByPayrollRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2           pgtype.Text        `json:"employee_id_2"`
	Position               pgtype.Text        `json:"position"`
	Email                  pgtype.Text        `json:"email"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetPayrollItemsByPayroll(ctx context.Context, payrollID uuid.UUID) ([]GetPayrollItemsByPayrollRow, error) {
	rows, err := q.db.Query(ctx, getPayrollItemsByPayroll, payrollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPayrollItemsByPayrollRow{}
	for rows.Next() {
		var i GetPayrollItemsByPayrollRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.BaseAmount,
			&i.BaseCurrency,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.ExchangeRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.Status,
			&i.TransactionHash,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.Notes,
			&i.TimesheetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.Position,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollPeriodByID = `-- name: GetPayrollPeriodByID :one
SELECT id, company_id, period_name, frequency, start_date, end_date, payment_date, status, is_recurring, next_period_id, created_at, updated_at FROM payroll_periods WHERE id = $1
`

func (q *Queries) GetPayrollPeriodByID(ctx context.Context, id uuid.UUID) (PayrollPeriods, error) {
	row := q.db.QueryRow(ctx, getPayrollPeriodByID, id)
	var i PayrollPeriods
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodName,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.PaymentDate,
		&i.Status,
		&i.IsRecurring,
		&i.NextPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayrollPeriodsByCompany = `-- name: GetPayrollPeriodsByCompany :many
SELECT id, company_id, period_name, frequency, start_date, end_date, payment_date, status, is_recurring, next_period_id, created_at, updated_at FROM payroll_periods 
WHERE company_id = $1
ORDER BY start_date DESC
`

func (q *Queries) GetPayrollPeriodsByCompany(ctx context.Context, companyID uuid.UUID) ([]PayrollPeriods, error) {
	rows, err := q.db.Query(ctx, getPayrollPeriodsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayrollPeriods{}
	for rows.Next() {
		var i PayrollPeriods
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PeriodName,
			&i.Frequency,
			&i.StartDate,
			&i.EndDate,
			&i.PaymentDate,
			&i.Status,
			&i.IsRecurring,
			&i.NextPeriodID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollsByCompany = `-- name: GetPayrollsByCompany :many
SELECT p.id, p.company_id, p.period_id, p.name, p.description, p.total_amount, p.base_currency, p.status, p.execution_type, p.scheduled_execution_time, p.executed_at, p.smart_contract_address, p.chain_id, p.transaction_hash, p.created_by, p.approved_by, p.created_at, p.updated_at, pp.period_name, pp.start_date, pp.end_date
FROM payrolls p
JOIN payroll_periods pp ON p.period_id = pp.id
WHERE p.company_id = $1
ORDER BY p.created_at DESC
`

type GetPayrollsByCompanyRow struct {
	ID                     uuid.UUID          `json:"id"`
	CompanyID              uuid.UUID          `json:"company_id"`
	PeriodID               uuid.UUID          `json:"period_id"`
	Name                   string             `json:"name"`
	Description            pgtype.Text        `json:"description"`
	TotalAmount            pgtype.Numeric     `json:"total_amount"`
	BaseCurrency           string             `json:"base_currency"`
	Status                 pgtype.Text        `json:"status"`
	ExecutionType          pgtype.Text        `json:"execution_type"`
	ScheduledExecutionTime pgtype.Timestamptz `json:"scheduled_execution_time"`
	ExecutedAt             pgtype.Timestamptz `json:"executed_at"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	CreatedBy              uuid.UUID          `json:"created_by"`
	ApprovedBy             pgtype.UUID        `json:"approved_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PeriodName             string             `json:"period_name"`
	StartDate              pgtype.Date        `json:"start_date"`
	EndDate                pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetPayrollsByCompany(ctx context.Context, companyID uuid.UUID) ([]GetPayrollsByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getPayrollsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPayrollsByCompanyRow{}
	for rows.Next() {
		var i GetPayrollsByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PeriodID,
			&i.Name,
			&i.Description,
			&i.TotalAmount,
			&i.BaseCurrency,
			&i.Status,
			&i.ExecutionType,
			&i.ScheduledExecutionTime,
			&i.ExecutedAt,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.TransactionHash,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayrollsByStatus = `-- name: GetPayrollsByStatus :many
SELECT p.id, p.company_id, p.period_id, p.name, p.description, p.total_amount, p.base_currency, p.status, p.execution_type, p.scheduled_execution_time, p.executed_at, p.smart_contract_address, p.chain_id, p.transaction_hash, p.created_by, p.approved_by, p.created_at, p.updated_at, pp.period_name, pp.start_date, pp.end_date
FROM payrolls p
JOIN payroll_periods pp ON p.period_id = pp.id
WHERE p.company_id = $1 AND p.status = $2
ORDER BY p.created_at DESC
`

type GetPayrollsByStatusParams struct {
	CompanyID uuid.UUID   `json:"company_id"`
	Status    pgtype.Text `json:"status"`
}

type GetPayrollsByStatusRow struct {
	ID                     uuid.UUID          `json:"id"`
	CompanyID              uuid.UUID          `json:"company_id"`
	PeriodID               uuid.UUID          `json:"period_id"`
	Name                   string             `json:"name"`
	Description            pgtype.Text        `json:"description"`
	TotalAmount            pgtype.Numeric     `json:"total_amount"`
	BaseCurrency           string             `json:"base_currency"`
	Status                 pgtype.Text        `json:"status"`
	ExecutionType          pgtype.Text        `json:"execution_type"`
	ScheduledExecutionTime pgtype.Timestamptz `json:"scheduled_execution_time"`
	ExecutedAt             pgtype.Timestamptz `json:"executed_at"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	CreatedBy              uuid.UUID          `json:"created_by"`
	ApprovedBy             pgtype.UUID        `json:"approved_by"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PeriodName             string             `json:"period_name"`
	StartDate              pgtype.Date        `json:"start_date"`
	EndDate                pgtype.Date        `json:"end_date"`
}

func (q *Queries) GetPayrollsByStatus(ctx context.Context, arg GetPayrollsByStatusParams) ([]GetPayrollsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getPayrollsByStatus, arg.CompanyID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPayrollsByStatusRow{}
	for rows.Next() {
		var i GetPayrollsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.PeriodID,
			&i.Name,
			&i.Description,
			&i.TotalAmount,
			&i.BaseCurrency,
			&i.Status,
			&i.ExecutionType,
			&i.ScheduledExecutionTime,
			&i.ExecutedAt,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.TransactionHash,
			&i.CreatedBy,
			&i.ApprovedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PeriodName,
			&i.StartDate,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingPayments = `-- name: GetUpcomingPayments :many
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, 
       ce.employee_id, ce.position,
       u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name,
       p.name as payroll_name,
       pp.payment_date
FROM payroll_items pi
JOIN company_employees ce ON pi.employee_id = ce.id
JOIN payrolls p ON pi.payroll_id = p.id
JOIN payroll_periods pp ON p.period_id = pp.id
LEFT JOIN users u ON ce.user_id = u.id
LEFT JOIN company_staff_profiles csp ON ce.user_id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE ce.user_id = $1 
  AND pi.status IN ('approved', 'processing')
  AND pp.payment_date >= CURRENT_DATE
ORDER BY pp.payment_date
`

type GetUpcomingPaymentsRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	EmployeeID_2           pgtype.Text        `json:"employee_id_2"`
	Position               pgtype.Text        `json:"position"`
	Email                  pgtype.Text        `json:"email"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	PayrollName            string             `json:"payroll_name"`
	PaymentDate            pgtype.Date        `json:"payment_date"`
}

func (q *Queries) GetUpcomingPayments(ctx context.Context, userID pgtype.UUID) ([]GetUpcomingPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingPayments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUpcomingPaymentsRow{}
	for rows.Next() {
		var i GetUpcomingPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.BaseAmount,
			&i.BaseCurrency,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.ExchangeRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.Status,
			&i.TransactionHash,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.Notes,
			&i.TimesheetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmployeeID_2,
			&i.Position,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.PayrollName,
			&i.PaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPayrollHistory = `-- name: GetUserPayrollHistory :many
SELECT pi.id, pi.payroll_id, pi.employee_id, pi.base_amount, pi.base_currency, pi.payment_amount, pi.payment_currency, pi.exchange_rate, pi.payment_method, pi.payment_split, pi.status, pi.transaction_hash, pi.recipient_wallet_address, pi.recipient_bank_account_id, pi.notes, pi.timesheet_id, pi.created_at, pi.updated_at, p.name as payroll_name, pp.period_name, c.company_name
FROM payroll_items pi
JOIN payrolls p ON pi.payroll_id = p.id
JOIN payroll_periods pp ON p.period_id = pp.id
JOIN companies c ON p.company_id = c.id
JOIN company_employees ce ON pi.employee_id = ce.id
WHERE ce.user_id = $1
ORDER BY pi.created_at DESC
LIMIT $3 OFFSET $2
`

type GetUserPayrollHistoryParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetUserPayrollHistoryRow struct {
	ID                     uuid.UUID          `json:"id"`
	PayrollID              uuid.UUID          `json:"payroll_id"`
	EmployeeID             uuid.UUID          `json:"employee_id"`
	BaseAmount             decimal.Decimal    `json:"base_amount"`
	BaseCurrency           string             `json:"base_currency"`
	PaymentAmount          decimal.Decimal    `json:"payment_amount"`
	PaymentCurrency        string             `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	PaymentMethod          string             `json:"payment_method"`
	PaymentSplit           []byte             `json:"payment_split"`
	Status                 pgtype.Text        `json:"status"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text        `json:"notes"`
	TimesheetID            pgtype.UUID        `json:"timesheet_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	PayrollName            string             `json:"payroll_name"`
	PeriodName             string             `json:"period_name"`
	CompanyName            string             `json:"company_name"`
}

func (q *Queries) GetUserPayrollHistory(ctx context.Context, arg GetUserPayrollHistoryParams) ([]GetUserPayrollHistoryRow, error) {
	rows, err := q.db.Query(ctx, getUserPayrollHistory, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPayrollHistoryRow{}
	for rows.Next() {
		var i GetUserPayrollHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.PayrollID,
			&i.EmployeeID,
			&i.BaseAmount,
			&i.BaseCurrency,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.ExchangeRate,
			&i.PaymentMethod,
			&i.PaymentSplit,
			&i.Status,
			&i.TransactionHash,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.Notes,
			&i.TimesheetID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PayrollName,
			&i.PeriodName,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayroll = `-- name: UpdatePayroll :one
UPDATE payrolls SET
  name = COALESCE($1, name),
  description = COALESCE($2, description),
  total_amount = COALESCE($3, total_amount),
  base_currency = COALESCE($4, base_currency),
  status = COALESCE($5, status),
  execution_type = COALESCE($6, execution_type),
  scheduled_execution_time = COALESCE($7, scheduled_execution_time),
  executed_at = COALESCE($8, executed_at),
  smart_contract_address = COALESCE($9, smart_contract_address),
  chain_id = COALESCE($10, chain_id),
  transaction_hash = COALESCE($11, transaction_hash),
  approved_by = COALESCE($12, approved_by),
  updated_at = NOW()
WHERE id = $13
RETURNING id, company_id, period_id, name, description, total_amount, base_currency, status, execution_type, scheduled_execution_time, executed_at, smart_contract_address, chain_id, transaction_hash, created_by, approved_by, created_at, updated_at
`

type UpdatePayrollParams struct {
	Name                   string             `json:"name"`
	Description            pgtype.Text        `json:"description"`
	TotalAmount            pgtype.Numeric     `json:"total_amount"`
	BaseCurrency           string             `json:"base_currency"`
	Status                 pgtype.Text        `json:"status"`
	ExecutionType          pgtype.Text        `json:"execution_type"`
	ScheduledExecutionTime pgtype.Timestamptz `json:"scheduled_execution_time"`
	ExecutedAt             pgtype.Timestamptz `json:"executed_at"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	ApprovedBy             pgtype.UUID        `json:"approved_by"`
	ID                     uuid.UUID          `json:"id"`
}

func (q *Queries) UpdatePayroll(ctx context.Context, arg UpdatePayrollParams) (Payrolls, error) {
	row := q.db.QueryRow(ctx, updatePayroll,
		arg.Name,
		arg.Description,
		arg.TotalAmount,
		arg.BaseCurrency,
		arg.Status,
		arg.ExecutionType,
		arg.ScheduledExecutionTime,
		arg.ExecutedAt,
		arg.SmartContractAddress,
		arg.ChainID,
		arg.TransactionHash,
		arg.ApprovedBy,
		arg.ID,
	)
	var i Payrolls
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodID,
		&i.Name,
		&i.Description,
		&i.TotalAmount,
		&i.BaseCurrency,
		&i.Status,
		&i.ExecutionType,
		&i.ScheduledExecutionTime,
		&i.ExecutedAt,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.TransactionHash,
		&i.CreatedBy,
		&i.ApprovedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayrollItem = `-- name: UpdatePayrollItem :one
UPDATE payroll_items SET
  base_amount = COALESCE($1, base_amount),
  base_currency = COALESCE($2, base_currency),
  payment_amount = COALESCE($3, payment_amount),
  payment_currency = COALESCE($4, payment_currency),
  exchange_rate = COALESCE($5, exchange_rate),
  payment_method = COALESCE($6, payment_method),
  payment_split = COALESCE($7, payment_split),
  status = COALESCE($8, status),
  transaction_hash = COALESCE($9, transaction_hash),
  recipient_wallet_address = COALESCE($10, recipient_wallet_address),
  recipient_bank_account_id = COALESCE($11, recipient_bank_account_id),
  notes = COALESCE($12, notes),
  timesheet_id = COALESCE($13, timesheet_id),
  updated_at = NOW()
WHERE id = $14
RETURNING id, payroll_id, employee_id, base_amount, base_currency, payment_amount, payment_currency, exchange_rate, payment_method, payment_split, status, transaction_hash, recipient_wallet_address, recipient_bank_account_id, notes, timesheet_id, created_at, updated_at
`

type UpdatePayrollItemParams struct {
	BaseAmount             decimal.Decimal `json:"base_amount"`
	BaseCurrency           string          `json:"base_currency"`
	PaymentAmount          decimal.Decimal `json:"payment_amount"`
	PaymentCurrency        string          `json:"payment_currency"`
	ExchangeRate           pgtype.Numeric  `json:"exchange_rate"`
	PaymentMethod          string          `json:"payment_method"`
	PaymentSplit           []byte          `json:"payment_split"`
	Status                 pgtype.Text     `json:"status"`
	TransactionHash        pgtype.Text     `json:"transaction_hash"`
	RecipientWalletAddress pgtype.Text     `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID     `json:"recipient_bank_account_id"`
	Notes                  pgtype.Text     `json:"notes"`
	TimesheetID            pgtype.UUID     `json:"timesheet_id"`
	ID                     uuid.UUID       `json:"id"`
}

func (q *Queries) UpdatePayrollItem(ctx context.Context, arg UpdatePayrollItemParams) (PayrollItems, error) {
	row := q.db.QueryRow(ctx, updatePayrollItem,
		arg.BaseAmount,
		arg.BaseCurrency,
		arg.PaymentAmount,
		arg.PaymentCurrency,
		arg.ExchangeRate,
		arg.PaymentMethod,
		arg.PaymentSplit,
		arg.Status,
		arg.TransactionHash,
		arg.RecipientWalletAddress,
		arg.RecipientBankAccountID,
		arg.Notes,
		arg.TimesheetID,
		arg.ID,
	)
	var i PayrollItems
	err := row.Scan(
		&i.ID,
		&i.PayrollID,
		&i.EmployeeID,
		&i.BaseAmount,
		&i.BaseCurrency,
		&i.PaymentAmount,
		&i.PaymentCurrency,
		&i.ExchangeRate,
		&i.PaymentMethod,
		&i.PaymentSplit,
		&i.Status,
		&i.TransactionHash,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.Notes,
		&i.TimesheetID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePayrollPeriod = `-- name: UpdatePayrollPeriod :one
UPDATE payroll_periods SET
  period_name = COALESCE($1, period_name),
  frequency = COALESCE($2, frequency),
  start_date = COALESCE($3, start_date),
  end_date = COALESCE($4, end_date),
  payment_date = COALESCE($5, payment_date),
  status = COALESCE($6, status),
  is_recurring = COALESCE($7, is_recurring),
  next_period_id = COALESCE($8, next_period_id),
  updated_at = NOW()
WHERE id = $9
RETURNING id, company_id, period_name, frequency, start_date, end_date, payment_date, status, is_recurring, next_period_id, created_at, updated_at
`

type UpdatePayrollPeriodParams struct {
	PeriodName   string      `json:"period_name"`
	Frequency    string      `json:"frequency"`
	StartDate    pgtype.Date `json:"start_date"`
	EndDate      pgtype.Date `json:"end_date"`
	PaymentDate  pgtype.Date `json:"payment_date"`
	Status       pgtype.Text `json:"status"`
	IsRecurring  pgtype.Bool `json:"is_recurring"`
	NextPeriodID pgtype.UUID `json:"next_period_id"`
	ID           uuid.UUID   `json:"id"`
}

func (q *Queries) UpdatePayrollPeriod(ctx context.Context, arg UpdatePayrollPeriodParams) (PayrollPeriods, error) {
	row := q.db.QueryRow(ctx, updatePayrollPeriod,
		arg.PeriodName,
		arg.Frequency,
		arg.StartDate,
		arg.EndDate,
		arg.PaymentDate,
		arg.Status,
		arg.IsRecurring,
		arg.NextPeriodID,
		arg.ID,
	)
	var i PayrollPeriods
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.PeriodName,
		&i.Frequency,
		&i.StartDate,
		&i.EndDate,
		&i.PaymentDate,
		&i.Status,
		&i.IsRecurring,
		&i.NextPeriodID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
