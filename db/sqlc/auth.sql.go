// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
DELETE FROM sessions 
WHERE expires_at < NOW() OR is_blocked = TRUE
`

func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const createSecurityEvent = `-- name: CreateSecurityEvent :one
INSERT INTO security_events (
  id,
  user_id,
  company_id,
  event_type,
  severity,
  ip_address,
  user_agent,
  metadata,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  COALESCE($9, NOW())
) RETURNING id, user_id, company_id, event_type, severity, ip_address, user_agent, metadata, created_at
`

type CreateSecurityEventParams struct {
	ID        interface{} `json:"id"`
	UserID    pgtype.UUID `json:"user_id"`
	CompanyID pgtype.UUID `json:"company_id"`
	EventType string      `json:"event_type"`
	Severity  string      `json:"severity"`
	IpAddress pgtype.Text `json:"ip_address"`
	UserAgent pgtype.Text `json:"user_agent"`
	Metadata  []byte      `json:"metadata"`
	CreatedAt interface{} `json:"created_at"`
}

func (q *Queries) CreateSecurityEvent(ctx context.Context, arg CreateSecurityEventParams) (SecurityEvents, error) {
	row := q.db.QueryRow(ctx, createSecurityEvent,
		arg.ID,
		arg.UserID,
		arg.CompanyID,
		arg.EventType,
		arg.Severity,
		arg.IpAddress,
		arg.UserAgent,
		arg.Metadata,
		arg.CreatedAt,
	)
	var i SecurityEvents
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.EventType,
		&i.Severity,
		&i.IpAddress,
		&i.UserAgent,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  id,
  user_id,
  refresh_token,
  user_agent,
  client_ip,
  last_used_at,
  web_oauth_client_id,
  oauth_access_token,
  oauth_id_token,
  user_login_type,
  mfa_verified,
  is_blocked,
  expires_at,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, NOW()),
  $7,
  $8,
  $9,
  $10,
  COALESCE($11, FALSE),
  COALESCE($12, FALSE),
  $13,
  COALESCE($14, NOW())
) RETURNING id, user_id, refresh_token, user_agent, client_ip, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_verified, is_blocked, expires_at, created_at
`

type CreateSessionParams struct {
	ID               interface{}        `json:"id"`
	UserID           uuid.UUID          `json:"user_id"`
	RefreshToken     pgtype.Text        `json:"refresh_token"`
	UserAgent        pgtype.Text        `json:"user_agent"`
	ClientIp         pgtype.Text        `json:"client_ip"`
	LastUsedAt       interface{}        `json:"last_used_at"`
	WebOauthClientID pgtype.Text        `json:"web_oauth_client_id"`
	OauthAccessToken pgtype.Text        `json:"oauth_access_token"`
	OauthIDToken     pgtype.Text        `json:"oauth_id_token"`
	UserLoginType    pgtype.Text        `json:"user_login_type"`
	MfaVerified      interface{}        `json:"mfa_verified"`
	IsBlocked        interface{}        `json:"is_blocked"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
	CreatedAt        interface{}        `json:"created_at"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.LastUsedAt,
		arg.WebOauthClientID,
		arg.OauthAccessToken,
		arg.OauthIDToken,
		arg.UserLoginType,
		arg.MfaVerified,
		arg.IsBlocked,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaVerified,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUserDevice = `-- name: CreateUserDevice :one
INSERT INTO user_devices (
  id,
  user_id,
  device_token,
  platform,
  device_type,
  device_model,
  os_name,
  os_version,
  push_notification_token,
  is_active,
  is_verified,
  last_used_at,
  app_version,
  client_ip,
  expires_at,
  is_revoked,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  COALESCE($10, TRUE),
  COALESCE($11, FALSE),
  COALESCE($12, NOW()),
  $13,
  $14,
  $15,
  COALESCE($16, FALSE),
  COALESCE($17, NOW()),
  COALESCE($18, NOW())
) RETURNING id, user_id, device_token, platform, device_type, device_model, os_name, os_version, push_notification_token, is_active, is_verified, last_used_at, app_version, client_ip, expires_at, is_revoked, created_at, updated_at
`

type CreateUserDeviceParams struct {
	ID                    interface{}        `json:"id"`
	UserID                uuid.UUID          `json:"user_id"`
	DeviceToken           pgtype.Text        `json:"device_token"`
	Platform              pgtype.Text        `json:"platform"`
	DeviceType            pgtype.Text        `json:"device_type"`
	DeviceModel           pgtype.Text        `json:"device_model"`
	OsName                pgtype.Text        `json:"os_name"`
	OsVersion             pgtype.Text        `json:"os_version"`
	PushNotificationToken pgtype.Text        `json:"push_notification_token"`
	IsActive              interface{}        `json:"is_active"`
	IsVerified            interface{}        `json:"is_verified"`
	LastUsedAt            interface{}        `json:"last_used_at"`
	AppVersion            pgtype.Text        `json:"app_version"`
	ClientIp              pgtype.Text        `json:"client_ip"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
	IsRevoked             interface{}        `json:"is_revoked"`
	CreatedAt             interface{}        `json:"created_at"`
	UpdatedAt             interface{}        `json:"updated_at"`
}

func (q *Queries) CreateUserDevice(ctx context.Context, arg CreateUserDeviceParams) (UserDevices, error) {
	row := q.db.QueryRow(ctx, createUserDevice,
		arg.ID,
		arg.UserID,
		arg.DeviceToken,
		arg.Platform,
		arg.DeviceType,
		arg.DeviceModel,
		arg.OsName,
		arg.OsVersion,
		arg.PushNotificationToken,
		arg.IsActive,
		arg.IsVerified,
		arg.LastUsedAt,
		arg.AppVersion,
		arg.ClientIp,
		arg.ExpiresAt,
		arg.IsRevoked,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UserDevices
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsName,
		&i.OsVersion,
		&i.PushNotificationToken,
		&i.IsActive,
		&i.IsVerified,
		&i.LastUsedAt,
		&i.AppVersion,
		&i.ClientIp,
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSecurityEventsByCompany = `-- name: GetSecurityEventsByCompany :many
SELECT id, user_id, company_id, event_type, severity, ip_address, user_agent, metadata, created_at FROM security_events 
WHERE company_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetSecurityEventsByCompanyParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

func (q *Queries) GetSecurityEventsByCompany(ctx context.Context, arg GetSecurityEventsByCompanyParams) ([]SecurityEvents, error) {
	rows, err := q.db.Query(ctx, getSecurityEventsByCompany, arg.CompanyID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityEvents{}
	for rows.Next() {
		var i SecurityEvents
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.EventType,
			&i.Severity,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityEventsByType = `-- name: GetSecurityEventsByType :many
SELECT id, user_id, company_id, event_type, severity, ip_address, user_agent, metadata, created_at FROM security_events 
WHERE event_type = $1 
  AND ($2::uuid IS NULL OR user_id = $2)
  AND ($3::uuid IS NULL OR company_id = $3)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type GetSecurityEventsByTypeParams struct {
	EventType string    `json:"event_type"`
	UserID    uuid.UUID `json:"user_id"`
	CompanyID uuid.UUID `json:"company_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

func (q *Queries) GetSecurityEventsByType(ctx context.Context, arg GetSecurityEventsByTypeParams) ([]SecurityEvents, error) {
	rows, err := q.db.Query(ctx, getSecurityEventsByType,
		arg.EventType,
		arg.UserID,
		arg.CompanyID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityEvents{}
	for rows.Next() {
		var i SecurityEvents
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.EventType,
			&i.Severity,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSecurityEventsByUser = `-- name: GetSecurityEventsByUser :many
SELECT id, user_id, company_id, event_type, severity, ip_address, user_agent, metadata, created_at FROM security_events 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetSecurityEventsByUserParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

func (q *Queries) GetSecurityEventsByUser(ctx context.Context, arg GetSecurityEventsByUserParams) ([]SecurityEvents, error) {
	rows, err := q.db.Query(ctx, getSecurityEventsByUser, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SecurityEvents{}
	for rows.Next() {
		var i SecurityEvents
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.EventType,
			&i.Severity,
			&i.IpAddress,
			&i.UserAgent,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, refresh_token, user_agent, client_ip, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_verified, is_blocked, expires_at, created_at FROM sessions 
WHERE id = $1 AND is_blocked = FALSE
`

func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Sessions, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.LastUsedAt,
		&i.WebOauthClientID,
		&i.OauthAccessToken,
		&i.OauthIDToken,
		&i.UserLoginType,
		&i.MfaVerified,
		&i.IsBlocked,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionsByUser = `-- name: GetSessionsByUser :many
SELECT id, user_id, refresh_token, user_agent, client_ip, last_used_at, web_oauth_client_id, oauth_access_token, oauth_id_token, user_login_type, mfa_verified, is_blocked, expires_at, created_at FROM sessions 
WHERE user_id = $1 AND is_blocked = FALSE
ORDER BY last_used_at DESC
`

func (q *Queries) GetSessionsByUser(ctx context.Context, userID uuid.UUID) ([]Sessions, error) {
	rows, err := q.db.Query(ctx, getSessionsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sessions{}
	for rows.Next() {
		var i Sessions
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshToken,
			&i.UserAgent,
			&i.ClientIp,
			&i.LastUsedAt,
			&i.WebOauthClientID,
			&i.OauthAccessToken,
			&i.OauthIDToken,
			&i.UserLoginType,
			&i.MfaVerified,
			&i.IsBlocked,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDeviceByID = `-- name: GetUserDeviceByID :one
SELECT id, user_id, device_token, platform, device_type, device_model, os_name, os_version, push_notification_token, is_active, is_verified, last_used_at, app_version, client_ip, expires_at, is_revoked, created_at, updated_at FROM user_devices 
WHERE id = $1 AND is_revoked = FALSE
`

func (q *Queries) GetUserDeviceByID(ctx context.Context, id uuid.UUID) (UserDevices, error) {
	row := q.db.QueryRow(ctx, getUserDeviceByID, id)
	var i UserDevices
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsName,
		&i.OsVersion,
		&i.PushNotificationToken,
		&i.IsActive,
		&i.IsVerified,
		&i.LastUsedAt,
		&i.AppVersion,
		&i.ClientIp,
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDeviceByToken = `-- name: GetUserDeviceByToken :one
SELECT id, user_id, device_token, platform, device_type, device_model, os_name, os_version, push_notification_token, is_active, is_verified, last_used_at, app_version, client_ip, expires_at, is_revoked, created_at, updated_at FROM user_devices 
WHERE device_token = $1 AND is_revoked = FALSE
`

func (q *Queries) GetUserDeviceByToken(ctx context.Context, deviceToken pgtype.Text) (UserDevices, error) {
	row := q.db.QueryRow(ctx, getUserDeviceByToken, deviceToken)
	var i UserDevices
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsName,
		&i.OsVersion,
		&i.PushNotificationToken,
		&i.IsActive,
		&i.IsVerified,
		&i.LastUsedAt,
		&i.AppVersion,
		&i.ClientIp,
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDevicesByUser = `-- name: GetUserDevicesByUser :many
SELECT id, user_id, device_token, platform, device_type, device_model, os_name, os_version, push_notification_token, is_active, is_verified, last_used_at, app_version, client_ip, expires_at, is_revoked, created_at, updated_at FROM user_devices 
WHERE user_id = $1 AND is_revoked = FALSE
ORDER BY last_used_at DESC
`

func (q *Queries) GetUserDevicesByUser(ctx context.Context, userID uuid.UUID) ([]UserDevices, error) {
	rows, err := q.db.Query(ctx, getUserDevicesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserDevices{}
	for rows.Next() {
		var i UserDevices
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceToken,
			&i.Platform,
			&i.DeviceType,
			&i.DeviceModel,
			&i.OsName,
			&i.OsVersion,
			&i.PushNotificationToken,
			&i.IsActive,
			&i.IsVerified,
			&i.LastUsedAt,
			&i.AppVersion,
			&i.ClientIp,
			&i.ExpiresAt,
			&i.IsRevoked,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAllUserSessions = `-- name: RevokeAllUserSessions :exec
UPDATE sessions SET
  is_blocked = TRUE
WHERE user_id = $1
`

func (q *Queries) RevokeAllUserSessions(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllUserSessions, userID)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE sessions SET
  is_blocked = TRUE
WHERE id = $1
`

func (q *Queries) RevokeSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeSession, id)
	return err
}

const revokeUserDevice = `-- name: RevokeUserDevice :exec
UPDATE user_devices SET
  is_revoked = TRUE,
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RevokeUserDevice(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeUserDevice, id)
	return err
}

const updateSessionLastUsed = `-- name: UpdateSessionLastUsed :exec
UPDATE sessions SET
  last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSessionLastUsed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSessionLastUsed, id)
	return err
}

const updateUserDevice = `-- name: UpdateUserDevice :one
UPDATE user_devices SET
  platform = COALESCE($1, platform),
  device_type = COALESCE($2, device_type),
  device_model = COALESCE($3, device_model),
  os_name = COALESCE($4, os_name),
  os_version = COALESCE($5, os_version),
  push_notification_token = COALESCE($6, push_notification_token),
  is_active = COALESCE($7, is_active),
  is_verified = COALESCE($8, is_verified),
  last_used_at = NOW(),
  app_version = COALESCE($9, app_version),
  client_ip = COALESCE($10, client_ip),
  expires_at = COALESCE($11, expires_at),
  updated_at = NOW()
WHERE id = $12
RETURNING id, user_id, device_token, platform, device_type, device_model, os_name, os_version, push_notification_token, is_active, is_verified, last_used_at, app_version, client_ip, expires_at, is_revoked, created_at, updated_at
`

type UpdateUserDeviceParams struct {
	Platform              pgtype.Text        `json:"platform"`
	DeviceType            pgtype.Text        `json:"device_type"`
	DeviceModel           pgtype.Text        `json:"device_model"`
	OsName                pgtype.Text        `json:"os_name"`
	OsVersion             pgtype.Text        `json:"os_version"`
	PushNotificationToken pgtype.Text        `json:"push_notification_token"`
	IsActive              pgtype.Bool        `json:"is_active"`
	IsVerified            pgtype.Bool        `json:"is_verified"`
	AppVersion            pgtype.Text        `json:"app_version"`
	ClientIp              pgtype.Text        `json:"client_ip"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
	ID                    uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateUserDevice(ctx context.Context, arg UpdateUserDeviceParams) (UserDevices, error) {
	row := q.db.QueryRow(ctx, updateUserDevice,
		arg.Platform,
		arg.DeviceType,
		arg.DeviceModel,
		arg.OsName,
		arg.OsVersion,
		arg.PushNotificationToken,
		arg.IsActive,
		arg.IsVerified,
		arg.AppVersion,
		arg.ClientIp,
		arg.ExpiresAt,
		arg.ID,
	)
	var i UserDevices
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DeviceToken,
		&i.Platform,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsName,
		&i.OsVersion,
		&i.PushNotificationToken,
		&i.IsActive,
		&i.IsVerified,
		&i.LastUsedAt,
		&i.AppVersion,
		&i.ClientIp,
		&i.ExpiresAt,
		&i.IsRevoked,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
