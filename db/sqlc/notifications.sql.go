// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notifications.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createNotification = `-- name: CreateNotification :one
INSERT INTO notifications (
  id,
  user_id,
  template_id,
  notification_type,
  title,
  content,
  reference_type,
  reference_id,
  is_read,
  read_at,
  delivery_status,
  priority,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  COALESCE($9, FALSE),
  $10,
  COALESCE($11, 'pending'),
  COALESCE($12, 'normal'),
  COALESCE($13, NOW())
) RETURNING id, user_id, template_id, notification_type, title, content, reference_type, reference_id, is_read, read_at, delivery_status, priority, created_at
`

type CreateNotificationParams struct {
	ID               interface{}        `json:"id"`
	UserID           uuid.UUID          `json:"user_id"`
	TemplateID       pgtype.UUID        `json:"template_id"`
	NotificationType string             `json:"notification_type"`
	Title            string             `json:"title"`
	Content          string             `json:"content"`
	ReferenceType    pgtype.Text        `json:"reference_type"`
	ReferenceID      pgtype.UUID        `json:"reference_id"`
	IsRead           interface{}        `json:"is_read"`
	ReadAt           pgtype.Timestamptz `json:"read_at"`
	DeliveryStatus   interface{}        `json:"delivery_status"`
	Priority         interface{}        `json:"priority"`
	CreatedAt        interface{}        `json:"created_at"`
}

func (q *Queries) CreateNotification(ctx context.Context, arg CreateNotificationParams) (Notifications, error) {
	row := q.db.QueryRow(ctx, createNotification,
		arg.ID,
		arg.UserID,
		arg.TemplateID,
		arg.NotificationType,
		arg.Title,
		arg.Content,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.IsRead,
		arg.ReadAt,
		arg.DeliveryStatus,
		arg.Priority,
		arg.CreatedAt,
	)
	var i Notifications
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TemplateID,
		&i.NotificationType,
		&i.Title,
		&i.Content,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.IsRead,
		&i.ReadAt,
		&i.DeliveryStatus,
		&i.Priority,
		&i.CreatedAt,
	)
	return i, err
}

const createNotificationTemplate = `-- name: CreateNotificationTemplate :one
INSERT INTO notification_templates (
  id,
  template_name,
  template_type,
  subject,
  content,
  variables,
  is_active,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  COALESCE($7, TRUE),
  COALESCE($8, NOW()),
  COALESCE($9, NOW())
) RETURNING id, template_name, template_type, subject, content, variables, is_active, created_at, updated_at
`

type CreateNotificationTemplateParams struct {
	ID           interface{} `json:"id"`
	TemplateName string      `json:"template_name"`
	TemplateType string      `json:"template_type"`
	Subject      pgtype.Text `json:"subject"`
	Content      string      `json:"content"`
	Variables    []byte      `json:"variables"`
	IsActive     interface{} `json:"is_active"`
	CreatedAt    interface{} `json:"created_at"`
	UpdatedAt    interface{} `json:"updated_at"`
}

func (q *Queries) CreateNotificationTemplate(ctx context.Context, arg CreateNotificationTemplateParams) (NotificationTemplates, error) {
	row := q.db.QueryRow(ctx, createNotificationTemplate,
		arg.ID,
		arg.TemplateName,
		arg.TemplateType,
		arg.Subject,
		arg.Content,
		arg.Variables,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i NotificationTemplates
	err := row.Scan(
		&i.ID,
		&i.TemplateName,
		&i.TemplateType,
		&i.Subject,
		&i.Content,
		&i.Variables,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (
  id,
  permission_key,
  description,
  category,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  COALESCE($5, NOW()),
  COALESCE($6, NOW())
) RETURNING id, permission_key, description, category, created_at, updated_at
`

type CreatePermissionParams struct {
	ID            interface{} `json:"id"`
	PermissionKey string      `json:"permission_key"`
	Description   pgtype.Text `json:"description"`
	Category      string      `json:"category"`
	CreatedAt     interface{} `json:"created_at"`
	UpdatedAt     interface{} `json:"updated_at"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permissions, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.ID,
		arg.PermissionKey,
		arg.Description,
		arg.Category,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Permissions
	err := row.Scan(
		&i.ID,
		&i.PermissionKey,
		&i.Description,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (
  id,
  company_id,
  role_name,
  description,
  is_system_role,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  COALESCE($5, FALSE),
  COALESCE($6, NOW()),
  COALESCE($7, NOW())
) RETURNING id, company_id, role_name, description, is_system_role, created_at, updated_at
`

type CreateRoleParams struct {
	ID           interface{} `json:"id"`
	CompanyID    pgtype.UUID `json:"company_id"`
	RoleName     string      `json:"role_name"`
	Description  pgtype.Text `json:"description"`
	IsSystemRole interface{} `json:"is_system_role"`
	CreatedAt    interface{} `json:"created_at"`
	UpdatedAt    interface{} `json:"updated_at"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Roles, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.CompanyID,
		arg.RoleName,
		arg.Description,
		arg.IsSystemRole,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Roles
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.RoleName,
		&i.Description,
		&i.IsSystemRole,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRolePermission = `-- name: CreateRolePermission :one
INSERT INTO role_permissions (
  id,
  role_id,
  permission_id,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  COALESCE($4, NOW())
) RETURNING id, role_id, permission_id, created_at
`

type CreateRolePermissionParams struct {
	ID           interface{} `json:"id"`
	RoleID       uuid.UUID   `json:"role_id"`
	PermissionID uuid.UUID   `json:"permission_id"`
	CreatedAt    interface{} `json:"created_at"`
}

func (q *Queries) CreateRolePermission(ctx context.Context, arg CreateRolePermissionParams) (RolePermissions, error) {
	row := q.db.QueryRow(ctx, createRolePermission,
		arg.ID,
		arg.RoleID,
		arg.PermissionID,
		arg.CreatedAt,
	)
	var i RolePermissions
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const createUserRole = `-- name: CreateUserRole :one
INSERT INTO user_roles (
  id,
  user_id,
  role_id,
  company_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  COALESCE($5, NOW()),
  COALESCE($6, NOW())
) RETURNING id, user_id, role_id, company_id, created_at, updated_at
`

type CreateUserRoleParams struct {
	ID        interface{} `json:"id"`
	UserID    uuid.UUID   `json:"user_id"`
	RoleID    uuid.UUID   `json:"role_id"`
	CompanyID pgtype.UUID `json:"company_id"`
	CreatedAt interface{} `json:"created_at"`
	UpdatedAt interface{} `json:"updated_at"`
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (UserRoles, error) {
	row := q.db.QueryRow(ctx, createUserRole,
		arg.ID,
		arg.UserID,
		arg.RoleID,
		arg.CompanyID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UserRoles
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoleID,
		&i.CompanyID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNotification = `-- name: DeleteNotification :exec
DELETE FROM notifications 
WHERE id = $1 AND user_id = $2
`

type DeleteNotificationParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteNotification(ctx context.Context, arg DeleteNotificationParams) error {
	_, err := q.db.Exec(ctx, deleteNotification, arg.ID, arg.UserID)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles 
WHERE id = $1 AND is_system_role = FALSE
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRole, id)
	return err
}

const deleteRolePermission = `-- name: DeleteRolePermission :exec
DELETE FROM role_permissions 
WHERE role_id = $1 AND permission_id = $2
`

type DeleteRolePermissionParams struct {
	RoleID       uuid.UUID `json:"role_id"`
	PermissionID uuid.UUID `json:"permission_id"`
}

func (q *Queries) DeleteRolePermission(ctx context.Context, arg DeleteRolePermissionParams) error {
	_, err := q.db.Exec(ctx, deleteRolePermission, arg.RoleID, arg.PermissionID)
	return err
}

const deleteUserRole = `-- name: DeleteUserRole :exec
DELETE FROM user_roles 
WHERE user_id = $1 AND role_id = $2 
  AND ($3::uuid IS NULL OR company_id = $3)
`

type DeleteUserRoleParams struct {
	UserID    uuid.UUID `json:"user_id"`
	RoleID    uuid.UUID `json:"role_id"`
	CompanyID uuid.UUID `json:"company_id"`
}

func (q *Queries) DeleteUserRole(ctx context.Context, arg DeleteUserRoleParams) error {
	_, err := q.db.Exec(ctx, deleteUserRole, arg.UserID, arg.RoleID, arg.CompanyID)
	return err
}

const getAllPermissions = `-- name: GetAllPermissions :many
SELECT id, permission_key, description, category, created_at, updated_at FROM permissions 
ORDER BY category, permission_key
`

func (q *Queries) GetAllPermissions(ctx context.Context) ([]Permissions, error) {
	rows, err := q.db.Query(ctx, getAllPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permissions{}
	for rows.Next() {
		var i Permissions
		if err := rows.Scan(
			&i.ID,
			&i.PermissionKey,
			&i.Description,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationCount = `-- name: GetNotificationCount :one
SELECT 
  COUNT(*) as total_count,
  COUNT(*) FILTER (WHERE is_read = FALSE) as unread_count
FROM notifications 
WHERE user_id = $1
`

type GetNotificationCountRow struct {
	TotalCount  int64 `json:"total_count"`
	UnreadCount int64 `json:"unread_count"`
}

func (q *Queries) GetNotificationCount(ctx context.Context, userID uuid.UUID) (GetNotificationCountRow, error) {
	row := q.db.QueryRow(ctx, getNotificationCount, userID)
	var i GetNotificationCountRow
	err := row.Scan(&i.TotalCount, &i.UnreadCount)
	return i, err
}

const getNotificationTemplateByName = `-- name: GetNotificationTemplateByName :one
SELECT id, template_name, template_type, subject, content, variables, is_active, created_at, updated_at FROM notification_templates 
WHERE template_name = $1 AND is_active = TRUE
`

func (q *Queries) GetNotificationTemplateByName(ctx context.Context, templateName string) (NotificationTemplates, error) {
	row := q.db.QueryRow(ctx, getNotificationTemplateByName, templateName)
	var i NotificationTemplates
	err := row.Scan(
		&i.ID,
		&i.TemplateName,
		&i.TemplateType,
		&i.Subject,
		&i.Content,
		&i.Variables,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotificationTemplatesByType = `-- name: GetNotificationTemplatesByType :many
SELECT id, template_name, template_type, subject, content, variables, is_active, created_at, updated_at FROM notification_templates 
WHERE template_type = $1 AND is_active = TRUE
ORDER BY template_name
`

func (q *Queries) GetNotificationTemplatesByType(ctx context.Context, templateType string) ([]NotificationTemplates, error) {
	rows, err := q.db.Query(ctx, getNotificationTemplatesByType, templateType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationTemplates{}
	for rows.Next() {
		var i NotificationTemplates
		if err := rows.Scan(
			&i.ID,
			&i.TemplateName,
			&i.TemplateType,
			&i.Subject,
			&i.Content,
			&i.Variables,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsByType = `-- name: GetNotificationsByType :many
SELECT n.id, n.user_id, n.template_id, n.notification_type, n.title, n.content, n.reference_type, n.reference_id, n.is_read, n.read_at, n.delivery_status, n.priority, n.created_at, nt.template_name
FROM notifications n
LEFT JOIN notification_templates nt ON n.template_id = nt.id
WHERE n.user_id = $1 AND n.notification_type = $2
ORDER BY n.created_at DESC
LIMIT $4 OFFSET $3
`

type GetNotificationsByTypeParams struct {
	UserID           uuid.UUID `json:"user_id"`
	NotificationType string    `json:"notification_type"`
	OffsetVal        int32     `json:"offset_val"`
	LimitVal         int32     `json:"limit_val"`
}

type GetNotificationsByTypeRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"user_id"`
	TemplateID       pgtype.UUID        `json:"template_id"`
	NotificationType string             `json:"notification_type"`
	Title            string             `json:"title"`
	Content          string             `json:"content"`
	ReferenceType    pgtype.Text        `json:"reference_type"`
	ReferenceID      pgtype.UUID        `json:"reference_id"`
	IsRead           pgtype.Bool        `json:"is_read"`
	ReadAt           pgtype.Timestamptz `json:"read_at"`
	DeliveryStatus   pgtype.Text        `json:"delivery_status"`
	Priority         pgtype.Text        `json:"priority"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	TemplateName     pgtype.Text        `json:"template_name"`
}

func (q *Queries) GetNotificationsByType(ctx context.Context, arg GetNotificationsByTypeParams) ([]GetNotificationsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsByType,
		arg.UserID,
		arg.NotificationType,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetNotificationsByTypeRow{}
	for rows.Next() {
		var i GetNotificationsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TemplateID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.IsRead,
			&i.ReadAt,
			&i.DeliveryStatus,
			&i.Priority,
			&i.CreatedAt,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissionsByCategory = `-- name: GetPermissionsByCategory :many
SELECT id, permission_key, description, category, created_at, updated_at FROM permissions 
WHERE category = $1
ORDER BY permission_key
`

func (q *Queries) GetPermissionsByCategory(ctx context.Context, category string) ([]Permissions, error) {
	rows, err := q.db.Query(ctx, getPermissionsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permissions{}
	for rows.Next() {
		var i Permissions
		if err := rows.Scan(
			&i.ID,
			&i.PermissionKey,
			&i.Description,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, company_id, role_name, description, is_system_role, created_at, updated_at FROM roles WHERE id = $1
`

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (Roles, error) {
	row := q.db.QueryRow(ctx, getRoleByID, id)
	var i Roles
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.RoleName,
		&i.Description,
		&i.IsSystemRole,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT rp.id, rp.role_id, rp.permission_id, rp.created_at, p.permission_key, p.description, p.category
FROM role_permissions rp
JOIN permissions p ON rp.permission_id = p.id
WHERE rp.role_id = $1
ORDER BY p.category, p.permission_key
`

type GetRolePermissionsRow struct {
	ID            uuid.UUID          `json:"id"`
	RoleID        uuid.UUID          `json:"role_id"`
	PermissionID  uuid.UUID          `json:"permission_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	PermissionKey string             `json:"permission_key"`
	Description   pgtype.Text        `json:"description"`
	Category      string             `json:"category"`
}

func (q *Queries) GetRolePermissions(ctx context.Context, roleID uuid.UUID) ([]GetRolePermissionsRow, error) {
	rows, err := q.db.Query(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRolePermissionsRow{}
	for rows.Next() {
		var i GetRolePermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.PermissionID,
			&i.CreatedAt,
			&i.PermissionKey,
			&i.Description,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolesByCompany = `-- name: GetRolesByCompany :many
SELECT id, company_id, role_name, description, is_system_role, created_at, updated_at FROM roles 
WHERE company_id = $1 OR is_system_role = TRUE
ORDER BY is_system_role DESC, role_name
`

func (q *Queries) GetRolesByCompany(ctx context.Context, companyID pgtype.UUID) ([]Roles, error) {
	rows, err := q.db.Query(ctx, getRolesByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Roles{}
	for rows.Next() {
		var i Roles
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.RoleName,
			&i.Description,
			&i.IsSystemRole,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadNotifications = `-- name: GetUnreadNotifications :many
SELECT n.id, n.user_id, n.template_id, n.notification_type, n.title, n.content, n.reference_type, n.reference_id, n.is_read, n.read_at, n.delivery_status, n.priority, n.created_at, nt.template_name
FROM notifications n
LEFT JOIN notification_templates nt ON n.template_id = nt.id
WHERE n.user_id = $1 AND n.is_read = FALSE
ORDER BY n.created_at DESC
`

type GetUnreadNotificationsRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"user_id"`
	TemplateID       pgtype.UUID        `json:"template_id"`
	NotificationType string             `json:"notification_type"`
	Title            string             `json:"title"`
	Content          string             `json:"content"`
	ReferenceType    pgtype.Text        `json:"reference_type"`
	ReferenceID      pgtype.UUID        `json:"reference_id"`
	IsRead           pgtype.Bool        `json:"is_read"`
	ReadAt           pgtype.Timestamptz `json:"read_at"`
	DeliveryStatus   pgtype.Text        `json:"delivery_status"`
	Priority         pgtype.Text        `json:"priority"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	TemplateName     pgtype.Text        `json:"template_name"`
}

func (q *Queries) GetUnreadNotifications(ctx context.Context, userID uuid.UUID) ([]GetUnreadNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getUnreadNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadNotificationsRow{}
	for rows.Next() {
		var i GetUnreadNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TemplateID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.IsRead,
			&i.ReadAt,
			&i.DeliveryStatus,
			&i.Priority,
			&i.CreatedAt,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotifications = `-- name: GetUserNotifications :many
SELECT n.id, n.user_id, n.template_id, n.notification_type, n.title, n.content, n.reference_type, n.reference_id, n.is_read, n.read_at, n.delivery_status, n.priority, n.created_at, nt.template_name
FROM notifications n
LEFT JOIN notification_templates nt ON n.template_id = nt.id
WHERE n.user_id = $1
ORDER BY n.created_at DESC
LIMIT $3 OFFSET $2
`

type GetUserNotificationsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetUserNotificationsRow struct {
	ID               uuid.UUID          `json:"id"`
	UserID           uuid.UUID          `json:"user_id"`
	TemplateID       pgtype.UUID        `json:"template_id"`
	NotificationType string             `json:"notification_type"`
	Title            string             `json:"title"`
	Content          string             `json:"content"`
	ReferenceType    pgtype.Text        `json:"reference_type"`
	ReferenceID      pgtype.UUID        `json:"reference_id"`
	IsRead           pgtype.Bool        `json:"is_read"`
	ReadAt           pgtype.Timestamptz `json:"read_at"`
	DeliveryStatus   pgtype.Text        `json:"delivery_status"`
	Priority         pgtype.Text        `json:"priority"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	TemplateName     pgtype.Text        `json:"template_name"`
}

func (q *Queries) GetUserNotifications(ctx context.Context, arg GetUserNotificationsParams) ([]GetUserNotificationsRow, error) {
	rows, err := q.db.Query(ctx, getUserNotifications, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserNotificationsRow{}
	for rows.Next() {
		var i GetUserNotificationsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TemplateID,
			&i.NotificationType,
			&i.Title,
			&i.Content,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.IsRead,
			&i.ReadAt,
			&i.DeliveryStatus,
			&i.Priority,
			&i.CreatedAt,
			&i.TemplateName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT DISTINCT p.permission_key, p.description, p.category
FROM user_roles ur
JOIN role_permissions rp ON ur.role_id = rp.role_id
JOIN permissions p ON rp.permission_id = p.id
WHERE ur.user_id = $1
  AND ($2::uuid IS NULL OR ur.company_id = $2)
ORDER BY p.category, p.permission_key
`

type GetUserPermissionsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	CompanyID uuid.UUID `json:"company_id"`
}

type GetUserPermissionsRow struct {
	PermissionKey string      `json:"permission_key"`
	Description   pgtype.Text `json:"description"`
	Category      string      `json:"category"`
}

func (q *Queries) GetUserPermissions(ctx context.Context, arg GetUserPermissionsParams) ([]GetUserPermissionsRow, error) {
	rows, err := q.db.Query(ctx, getUserPermissions, arg.UserID, arg.CompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPermissionsRow{}
	for rows.Next() {
		var i GetUserPermissionsRow
		if err := rows.Scan(&i.PermissionKey, &i.Description, &i.Category); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT ur.id, ur.user_id, ur.role_id, ur.company_id, ur.created_at, ur.updated_at, r.role_name, r.description, c.company_name
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
LEFT JOIN companies c ON ur.company_id = c.id
WHERE ur.user_id = $1
ORDER BY c.company_name, r.role_name
`

type GetUserRolesRow struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	RoleID      uuid.UUID          `json:"role_id"`
	CompanyID   pgtype.UUID        `json:"company_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RoleName    string             `json:"role_name"`
	Description pgtype.Text        `json:"description"`
	CompanyName pgtype.Text        `json:"company_name"`
}

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]GetUserRolesRow, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRolesRow{}
	for rows.Next() {
		var i GetUserRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.CompanyID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.Description,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRolesByCompany = `-- name: GetUserRolesByCompany :many
SELECT ur.id, ur.user_id, ur.role_id, ur.company_id, ur.created_at, ur.updated_at, r.role_name, r.description
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.user_id = $1 AND ur.company_id = $2
ORDER BY r.role_name
`

type GetUserRolesByCompanyParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	CompanyID pgtype.UUID `json:"company_id"`
}

type GetUserRolesByCompanyRow struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	RoleID      uuid.UUID          `json:"role_id"`
	CompanyID   pgtype.UUID        `json:"company_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	RoleName    string             `json:"role_name"`
	Description pgtype.Text        `json:"description"`
}

func (q *Queries) GetUserRolesByCompany(ctx context.Context, arg GetUserRolesByCompanyParams) ([]GetUserRolesByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getUserRolesByCompany, arg.UserID, arg.CompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserRolesByCompanyRow{}
	for rows.Next() {
		var i GetUserRolesByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.CompanyID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRole = `-- name: GetUsersWithRole :many
SELECT ur.id, ur.user_id, ur.role_id, ur.company_id, ur.created_at, ur.updated_at, u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM user_roles ur
JOIN users u ON ur.user_id = u.id
LEFT JOIN company_staff_profiles csp ON u.id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE ur.role_id = $1
  AND ($2::uuid IS NULL OR ur.company_id = $2)
ORDER BY u.email
`

type GetUsersWithRoleParams struct {
	RoleID    uuid.UUID `json:"role_id"`
	CompanyID uuid.UUID `json:"company_id"`
}

type GetUsersWithRoleRow struct {
	ID        uuid.UUID          `json:"id"`
	UserID    uuid.UUID          `json:"user_id"`
	RoleID    uuid.UUID          `json:"role_id"`
	CompanyID pgtype.UUID        `json:"company_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Email     string             `json:"email"`
	FirstName pgtype.Text        `json:"first_name"`
	LastName  pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetUsersWithRole(ctx context.Context, arg GetUsersWithRoleParams) ([]GetUsersWithRoleRow, error) {
	rows, err := q.db.Query(ctx, getUsersWithRole, arg.RoleID, arg.CompanyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersWithRoleRow{}
	for rows.Next() {
		var i GetUsersWithRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.CompanyID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllNotificationsAsRead = `-- name: MarkAllNotificationsAsRead :exec
UPDATE notifications SET
  is_read = TRUE,
  read_at = NOW()
WHERE user_id = $1 AND is_read = FALSE
`

func (q *Queries) MarkAllNotificationsAsRead(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAllNotificationsAsRead, userID)
	return err
}

const markNotificationAsRead = `-- name: MarkNotificationAsRead :one
UPDATE notifications SET
  is_read = TRUE,
  read_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, template_id, notification_type, title, content, reference_type, reference_id, is_read, read_at, delivery_status, priority, created_at
`

type MarkNotificationAsReadParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) MarkNotificationAsRead(ctx context.Context, arg MarkNotificationAsReadParams) (Notifications, error) {
	row := q.db.QueryRow(ctx, markNotificationAsRead, arg.ID, arg.UserID)
	var i Notifications
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TemplateID,
		&i.NotificationType,
		&i.Title,
		&i.Content,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.IsRead,
		&i.ReadAt,
		&i.DeliveryStatus,
		&i.Priority,
		&i.CreatedAt,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles SET
  role_name = COALESCE($1, role_name),
  description = COALESCE($2, description),
  updated_at = NOW()
WHERE id = $3 AND is_system_role = FALSE
RETURNING id, company_id, role_name, description, is_system_role, created_at, updated_at
`

type UpdateRoleParams struct {
	RoleName    string      `json:"role_name"`
	Description pgtype.Text `json:"description"`
	ID          uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Roles, error) {
	row := q.db.QueryRow(ctx, updateRole, arg.RoleName, arg.Description, arg.ID)
	var i Roles
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.RoleName,
		&i.Description,
		&i.IsSystemRole,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
