// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPersonalUser = `-- name: CreatePersonalUser :one
INSERT INTO personal_users (
  id,
  first_name,
  last_name,
  profile_picture,
  phone_number,
  phone_number_verified,
  phone_number_verified_at,
  nationality,
  residential_country,
  user_address,
  user_city,
  user_postal_code,
  gender,
  date_of_birth,
  job_role,
  personal_account_type,
  employment_type,
  tax_id,
  default_payment_currency,
  default_payment_method,
  hourly_rate,
  specialization,
  kyc_status,
  kyc_verified_at,
  created_at,
  updated_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, FALSE),
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $20,
  $21,
  $22,
  COALESCE($23, 'pending'),
  $24,
  COALESCE($25, NOW()),
  COALESCE($26, NOW())
) RETURNING id, first_name, last_name, profile_picture, phone_number, phone_number_verified, phone_number_verified_at, nationality, residential_country, user_address, user_city, user_postal_code, gender, date_of_birth, job_role, personal_account_type, employment_type, tax_id, default_payment_currency, default_payment_method, hourly_rate, specialization, kyc_status, kyc_verified_at, created_at, updated_at
`

type CreatePersonalUserParams struct {
	ID                     uuid.UUID          `json:"id"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	ProfilePicture         pgtype.Text        `json:"profile_picture"`
	PhoneNumber            pgtype.Text        `json:"phone_number"`
	PhoneNumberVerified    interface{}        `json:"phone_number_verified"`
	PhoneNumberVerifiedAt  pgtype.Timestamptz `json:"phone_number_verified_at"`
	Nationality            pgtype.Text        `json:"nationality"`
	ResidentialCountry     pgtype.Text        `json:"residential_country"`
	UserAddress            pgtype.Text        `json:"user_address"`
	UserCity               pgtype.Text        `json:"user_city"`
	UserPostalCode         pgtype.Text        `json:"user_postal_code"`
	Gender                 pgtype.Text        `json:"gender"`
	DateOfBirth            pgtype.Date        `json:"date_of_birth"`
	JobRole                pgtype.Text        `json:"job_role"`
	PersonalAccountType    pgtype.Text        `json:"personal_account_type"`
	EmploymentType         pgtype.Text        `json:"employment_type"`
	TaxID                  pgtype.Text        `json:"tax_id"`
	DefaultPaymentCurrency pgtype.Text        `json:"default_payment_currency"`
	DefaultPaymentMethod   pgtype.Text        `json:"default_payment_method"`
	HourlyRate             pgtype.Numeric     `json:"hourly_rate"`
	Specialization         pgtype.Text        `json:"specialization"`
	KycStatus              interface{}        `json:"kyc_status"`
	KycVerifiedAt          pgtype.Timestamptz `json:"kyc_verified_at"`
	CreatedAt              interface{}        `json:"created_at"`
	UpdatedAt              interface{}        `json:"updated_at"`
}

func (q *Queries) CreatePersonalUser(ctx context.Context, arg CreatePersonalUserParams) (PersonalUsers, error) {
	row := q.db.QueryRow(ctx, createPersonalUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.ProfilePicture,
		arg.PhoneNumber,
		arg.PhoneNumberVerified,
		arg.PhoneNumberVerifiedAt,
		arg.Nationality,
		arg.ResidentialCountry,
		arg.UserAddress,
		arg.UserCity,
		arg.UserPostalCode,
		arg.Gender,
		arg.DateOfBirth,
		arg.JobRole,
		arg.PersonalAccountType,
		arg.EmploymentType,
		arg.TaxID,
		arg.DefaultPaymentCurrency,
		arg.DefaultPaymentMethod,
		arg.HourlyRate,
		arg.Specialization,
		arg.KycStatus,
		arg.KycVerifiedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i PersonalUsers
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.ProfilePicture,
		&i.PhoneNumber,
		&i.PhoneNumberVerified,
		&i.PhoneNumberVerifiedAt,
		&i.Nationality,
		&i.ResidentialCountry,
		&i.UserAddress,
		&i.UserCity,
		&i.UserPostalCode,
		&i.Gender,
		&i.DateOfBirth,
		&i.JobRole,
		&i.PersonalAccountType,
		&i.EmploymentType,
		&i.TaxID,
		&i.DefaultPaymentCurrency,
		&i.DefaultPaymentMethod,
		&i.HourlyRate,
		&i.Specialization,
		&i.KycStatus,
		&i.KycVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id,
  email,
  password_hash,
  auth_provider,
  provider_id,
  email_verified,
  email_verified_at,
  account_type,
  account_status,
  two_factor_enabled,
  two_factor_method,
  user_login_type,
  created_at,
  updated_at,
  last_login_at,
  deleted_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  COALESCE($6, FALSE),
  $7,
  $8,
  COALESCE($9, 'pending'),
  COALESCE($10, FALSE),
  $11,
  $12,
  COALESCE($13, NOW()),
  COALESCE($14, NOW()),
  $15,
  $16
) RETURNING id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at
`

type CreateUserParams struct {
	ID               interface{}        `json:"id"`
	Email            string             `json:"email"`
	PasswordHash     pgtype.Text        `json:"password_hash"`
	AuthProvider     pgtype.Text        `json:"auth_provider"`
	ProviderID       pgtype.Text        `json:"provider_id"`
	EmailVerified    interface{}        `json:"email_verified"`
	EmailVerifiedAt  pgtype.Timestamptz `json:"email_verified_at"`
	AccountType      string             `json:"account_type"`
	AccountStatus    interface{}        `json:"account_status"`
	TwoFactorEnabled interface{}        `json:"two_factor_enabled"`
	TwoFactorMethod  pgtype.Text        `json:"two_factor_method"`
	UserLoginType    pgtype.Text        `json:"user_login_type"`
	CreatedAt        interface{}        `json:"created_at"`
	UpdatedAt        interface{}        `json:"updated_at"`
	LastLoginAt      pgtype.Timestamptz `json:"last_login_at"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.AuthProvider,
		arg.ProviderID,
		arg.EmailVerified,
		arg.EmailVerifiedAt,
		arg.AccountType,
		arg.AccountStatus,
		arg.TwoFactorEnabled,
		arg.TwoFactorMethod,
		arg.UserLoginType,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastLoginAt,
		arg.DeletedAt,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.AuthProvider,
		&i.ProviderID,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.AccountType,
		&i.AccountStatus,
		&i.TwoFactorEnabled,
		&i.TwoFactorMethod,
		&i.UserLoginType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPersonalUserByID = `-- name: GetPersonalUserByID :one
SELECT pu.id, pu.first_name, pu.last_name, pu.profile_picture, pu.phone_number, pu.phone_number_verified, pu.phone_number_verified_at, pu.nationality, pu.residential_country, pu.user_address, pu.user_city, pu.user_postal_code, pu.gender, pu.date_of_birth, pu.job_role, pu.personal_account_type, pu.employment_type, pu.tax_id, pu.default_payment_currency, pu.default_payment_method, pu.hourly_rate, pu.specialization, pu.kyc_status, pu.kyc_verified_at, pu.created_at, pu.updated_at, u.email, u.account_status
FROM personal_users pu
JOIN users u ON pu.id = u.id
WHERE pu.id = $1 AND u.deleted_at IS NULL
`

type GetPersonalUserByIDRow struct {
	ID                     uuid.UUID          `json:"id"`
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	ProfilePicture         pgtype.Text        `json:"profile_picture"`
	PhoneNumber            pgtype.Text        `json:"phone_number"`
	PhoneNumberVerified    pgtype.Bool        `json:"phone_number_verified"`
	PhoneNumberVerifiedAt  pgtype.Timestamptz `json:"phone_number_verified_at"`
	Nationality            pgtype.Text        `json:"nationality"`
	ResidentialCountry     pgtype.Text        `json:"residential_country"`
	UserAddress            pgtype.Text        `json:"user_address"`
	UserCity               pgtype.Text        `json:"user_city"`
	UserPostalCode         pgtype.Text        `json:"user_postal_code"`
	Gender                 pgtype.Text        `json:"gender"`
	DateOfBirth            pgtype.Date        `json:"date_of_birth"`
	JobRole                pgtype.Text        `json:"job_role"`
	PersonalAccountType    pgtype.Text        `json:"personal_account_type"`
	EmploymentType         pgtype.Text        `json:"employment_type"`
	TaxID                  pgtype.Text        `json:"tax_id"`
	DefaultPaymentCurrency pgtype.Text        `json:"default_payment_currency"`
	DefaultPaymentMethod   pgtype.Text        `json:"default_payment_method"`
	HourlyRate             pgtype.Numeric     `json:"hourly_rate"`
	Specialization         pgtype.Text        `json:"specialization"`
	KycStatus              pgtype.Text        `json:"kyc_status"`
	KycVerifiedAt          pgtype.Timestamptz `json:"kyc_verified_at"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	Email                  string             `json:"email"`
	AccountStatus          pgtype.Text        `json:"account_status"`
}

func (q *Queries) GetPersonalUserByID(ctx context.Context, id uuid.UUID) (GetPersonalUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getPersonalUserByID, id)
	var i GetPersonalUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.ProfilePicture,
		&i.PhoneNumber,
		&i.PhoneNumberVerified,
		&i.PhoneNumberVerifiedAt,
		&i.Nationality,
		&i.ResidentialCountry,
		&i.UserAddress,
		&i.UserCity,
		&i.UserPostalCode,
		&i.Gender,
		&i.DateOfBirth,
		&i.JobRole,
		&i.PersonalAccountType,
		&i.EmploymentType,
		&i.TaxID,
		&i.DefaultPaymentCurrency,
		&i.DefaultPaymentMethod,
		&i.HourlyRate,
		&i.Specialization,
		&i.KycStatus,
		&i.KycVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.AccountStatus,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at FROM users 
WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.AuthProvider,
		&i.ProviderID,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.AccountType,
		&i.AccountStatus,
		&i.TwoFactorEnabled,
		&i.TwoFactorMethod,
		&i.UserLoginType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at FROM users 
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (Users, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.AuthProvider,
		&i.ProviderID,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.AccountType,
		&i.AccountStatus,
		&i.TwoFactorEnabled,
		&i.TwoFactorMethod,
		&i.UserLoginType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUsersByAccountType = `-- name: GetUsersByAccountType :many
SELECT id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at FROM users 
WHERE account_type = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetUsersByAccountTypeParams struct {
	AccountType string `json:"account_type"`
	OffsetVal   int32  `json:"offset_val"`
	LimitVal    int32  `json:"limit_val"`
}

func (q *Queries) GetUsersByAccountType(ctx context.Context, arg GetUsersByAccountTypeParams) ([]Users, error) {
	rows, err := q.db.Query(ctx, getUsersByAccountType, arg.AccountType, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.AuthProvider,
			&i.ProviderID,
			&i.EmailVerified,
			&i.EmailVerifiedAt,
			&i.AccountType,
			&i.AccountStatus,
			&i.TwoFactorEnabled,
			&i.TwoFactorMethod,
			&i.UserLoginType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at FROM users 
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListUsersParams struct {
	OffsetVal int32 `json:"offset_val"`
	LimitVal  int32 `json:"limit_val"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]Users, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.AuthProvider,
			&i.ProviderID,
			&i.EmailVerified,
			&i.EmailVerifiedAt,
			&i.AccountType,
			&i.AccountStatus,
			&i.TwoFactorEnabled,
			&i.TwoFactorMethod,
			&i.UserLoginType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at FROM users 
WHERE email ILIKE '%' || $1 || '%'
  AND deleted_at IS NULL
ORDER BY email
LIMIT $3 OFFSET $2
`

type SearchUsersByEmailParams struct {
	SearchTerm pgtype.Text `json:"search_term"`
	OffsetVal  int32       `json:"offset_val"`
	LimitVal   int32       `json:"limit_val"`
}

func (q *Queries) SearchUsersByEmail(ctx context.Context, arg SearchUsersByEmailParams) ([]Users, error) {
	rows, err := q.db.Query(ctx, searchUsersByEmail, arg.SearchTerm, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.AuthProvider,
			&i.ProviderID,
			&i.EmailVerified,
			&i.EmailVerifiedAt,
			&i.AccountType,
			&i.AccountStatus,
			&i.TwoFactorEnabled,
			&i.TwoFactorMethod,
			&i.UserLoginType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, id)
	return err
}

const updatePersonalUser = `-- name: UpdatePersonalUser :one
UPDATE personal_users SET
  first_name = COALESCE($1, first_name),
  last_name = COALESCE($2, last_name),
  profile_picture = COALESCE($3, profile_picture),
  phone_number = COALESCE($4, phone_number),
  phone_number_verified = COALESCE($5, phone_number_verified),
  phone_number_verified_at = COALESCE($6, phone_number_verified_at),
  nationality = COALESCE($7, nationality),
  residential_country = COALESCE($8, residential_country),
  user_address = COALESCE($9, user_address),
  user_city = COALESCE($10, user_city),
  user_postal_code = COALESCE($11, user_postal_code),
  gender = COALESCE($12, gender),
  date_of_birth = COALESCE($13, date_of_birth),
  job_role = COALESCE($14, job_role),
  employment_type = COALESCE($15, employment_type),
  tax_id = COALESCE($16, tax_id),
  default_payment_currency = COALESCE($17, default_payment_currency),
  default_payment_method = COALESCE($18, default_payment_method),
  hourly_rate = COALESCE($19, hourly_rate),
  specialization = COALESCE($20, specialization),
  kyc_status = COALESCE($21, kyc_status),
  kyc_verified_at = COALESCE($22, kyc_verified_at),
  updated_at = NOW()
WHERE id = $23
RETURNING id, first_name, last_name, profile_picture, phone_number, phone_number_verified, phone_number_verified_at, nationality, residential_country, user_address, user_city, user_postal_code, gender, date_of_birth, job_role, personal_account_type, employment_type, tax_id, default_payment_currency, default_payment_method, hourly_rate, specialization, kyc_status, kyc_verified_at, created_at, updated_at
`

type UpdatePersonalUserParams struct {
	FirstName              pgtype.Text        `json:"first_name"`
	LastName               pgtype.Text        `json:"last_name"`
	ProfilePicture         pgtype.Text        `json:"profile_picture"`
	PhoneNumber            pgtype.Text        `json:"phone_number"`
	PhoneNumberVerified    pgtype.Bool        `json:"phone_number_verified"`
	PhoneNumberVerifiedAt  pgtype.Timestamptz `json:"phone_number_verified_at"`
	Nationality            pgtype.Text        `json:"nationality"`
	ResidentialCountry     pgtype.Text        `json:"residential_country"`
	UserAddress            pgtype.Text        `json:"user_address"`
	UserCity               pgtype.Text        `json:"user_city"`
	UserPostalCode         pgtype.Text        `json:"user_postal_code"`
	Gender                 pgtype.Text        `json:"gender"`
	DateOfBirth            pgtype.Date        `json:"date_of_birth"`
	JobRole                pgtype.Text        `json:"job_role"`
	EmploymentType         pgtype.Text        `json:"employment_type"`
	TaxID                  pgtype.Text        `json:"tax_id"`
	DefaultPaymentCurrency pgtype.Text        `json:"default_payment_currency"`
	DefaultPaymentMethod   pgtype.Text        `json:"default_payment_method"`
	HourlyRate             pgtype.Numeric     `json:"hourly_rate"`
	Specialization         pgtype.Text        `json:"specialization"`
	KycStatus              pgtype.Text        `json:"kyc_status"`
	KycVerifiedAt          pgtype.Timestamptz `json:"kyc_verified_at"`
	ID                     uuid.UUID          `json:"id"`
}

func (q *Queries) UpdatePersonalUser(ctx context.Context, arg UpdatePersonalUserParams) (PersonalUsers, error) {
	row := q.db.QueryRow(ctx, updatePersonalUser,
		arg.FirstName,
		arg.LastName,
		arg.ProfilePicture,
		arg.PhoneNumber,
		arg.PhoneNumberVerified,
		arg.PhoneNumberVerifiedAt,
		arg.Nationality,
		arg.ResidentialCountry,
		arg.UserAddress,
		arg.UserCity,
		arg.UserPostalCode,
		arg.Gender,
		arg.DateOfBirth,
		arg.JobRole,
		arg.EmploymentType,
		arg.TaxID,
		arg.DefaultPaymentCurrency,
		arg.DefaultPaymentMethod,
		arg.HourlyRate,
		arg.Specialization,
		arg.KycStatus,
		arg.KycVerifiedAt,
		arg.ID,
	)
	var i PersonalUsers
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.ProfilePicture,
		&i.PhoneNumber,
		&i.PhoneNumberVerified,
		&i.PhoneNumberVerifiedAt,
		&i.Nationality,
		&i.ResidentialCountry,
		&i.UserAddress,
		&i.UserCity,
		&i.UserPostalCode,
		&i.Gender,
		&i.DateOfBirth,
		&i.JobRole,
		&i.PersonalAccountType,
		&i.EmploymentType,
		&i.TaxID,
		&i.DefaultPaymentCurrency,
		&i.DefaultPaymentMethod,
		&i.HourlyRate,
		&i.Specialization,
		&i.KycStatus,
		&i.KycVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
  password_hash = COALESCE($1, password_hash),
  auth_provider = COALESCE($2, auth_provider),
  provider_id = COALESCE($3, provider_id),
  email_verified = COALESCE($4, email_verified),
  email_verified_at = COALESCE($5, email_verified_at),
  account_status = COALESCE($6, account_status),
  two_factor_enabled = COALESCE($7, two_factor_enabled),
  two_factor_method = COALESCE($8, two_factor_method),
  last_login_at = COALESCE($9, last_login_at),
  updated_at = NOW()
WHERE id = $10 AND deleted_at IS NULL
RETURNING id, email, password_hash, auth_provider, provider_id, email_verified, email_verified_at, account_type, account_status, two_factor_enabled, two_factor_method, user_login_type, created_at, updated_at, last_login_at, deleted_at
`

type UpdateUserParams struct {
	PasswordHash     pgtype.Text        `json:"password_hash"`
	AuthProvider     pgtype.Text        `json:"auth_provider"`
	ProviderID       pgtype.Text        `json:"provider_id"`
	EmailVerified    pgtype.Bool        `json:"email_verified"`
	EmailVerifiedAt  pgtype.Timestamptz `json:"email_verified_at"`
	AccountStatus    pgtype.Text        `json:"account_status"`
	TwoFactorEnabled pgtype.Bool        `json:"two_factor_enabled"`
	TwoFactorMethod  pgtype.Text        `json:"two_factor_method"`
	LastLoginAt      pgtype.Timestamptz `json:"last_login_at"`
	ID               uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (Users, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.PasswordHash,
		arg.AuthProvider,
		arg.ProviderID,
		arg.EmailVerified,
		arg.EmailVerifiedAt,
		arg.AccountStatus,
		arg.TwoFactorEnabled,
		arg.TwoFactorMethod,
		arg.LastLoginAt,
		arg.ID,
	)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.AuthProvider,
		&i.ProviderID,
		&i.EmailVerified,
		&i.EmailVerifiedAt,
		&i.AccountType,
		&i.AccountStatus,
		&i.TwoFactorEnabled,
		&i.TwoFactorMethod,
		&i.UserLoginType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserLoginTime = `-- name: UpdateUserLoginTime :exec
UPDATE users SET
  last_login_at = NOW(),
  updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLoginTime(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateUserLoginTime, id)
	return err
}
