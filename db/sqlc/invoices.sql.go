// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (
  id,
  invoice_number,
  issuer_id,
  recipient_id,
  title,
  description,
  issue_date,
  due_date,
  total_amount,
  currency,
  status,
  payment_method,
  recipient_wallet_address,
  recipient_bank_account_id,
  transaction_hash,
  payment_date,
  rejection_reason,
  ipfs_hash,
  smart_contract_address,
  chain_id,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  COALESCE($11, 'draft'),
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $20,
  COALESCE($21, NOW()),
  COALESCE($22, NOW())
) RETURNING id, invoice_number, issuer_id, recipient_id, title, description, issue_date, due_date, total_amount, currency, status, payment_method, recipient_wallet_address, recipient_bank_account_id, transaction_hash, payment_date, rejection_reason, ipfs_hash, smart_contract_address, chain_id, created_at, updated_at
`

type CreateInvoiceParams struct {
	ID                     interface{}        `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 interface{}        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              interface{}        `json:"created_at"`
	UpdatedAt              interface{}        `json:"updated_at"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoices, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.ID,
		arg.InvoiceNumber,
		arg.IssuerID,
		arg.RecipientID,
		arg.Title,
		arg.Description,
		arg.IssueDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethod,
		arg.RecipientWalletAddress,
		arg.RecipientBankAccountID,
		arg.TransactionHash,
		arg.PaymentDate,
		arg.RejectionReason,
		arg.IpfsHash,
		arg.SmartContractAddress,
		arg.ChainID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Invoices
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.IssuerID,
		&i.RecipientID,
		&i.Title,
		&i.Description,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.TransactionHash,
		&i.PaymentDate,
		&i.RejectionReason,
		&i.IpfsHash,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInvoiceItem = `-- name: CreateInvoiceItem :one
INSERT INTO invoice_items (
  id,
  invoice_id,
  description,
  quantity,
  unit_price,
  amount,
  tax_rate,
  tax_amount,
  discount_percentage,
  discount_amount,
  total_amount,
  created_at,
  updated_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  COALESCE($4, 1),
  $5,
  $6,
  COALESCE($7, 0),
  COALESCE($8, 0),
  COALESCE($9, 0),
  COALESCE($10, 0),
  $11,
  COALESCE($12, NOW()),
  COALESCE($13, NOW())
) RETURNING id, invoice_id, description, quantity, unit_price, amount, tax_rate, tax_amount, discount_percentage, discount_amount, total_amount, created_at, updated_at
`

type CreateInvoiceItemParams struct {
	ID                 interface{}     `json:"id"`
	InvoiceID          uuid.UUID       `json:"invoice_id"`
	Description        string          `json:"description"`
	Quantity           interface{}     `json:"quantity"`
	UnitPrice          decimal.Decimal `json:"unit_price"`
	Amount             decimal.Decimal `json:"amount"`
	TaxRate            interface{}     `json:"tax_rate"`
	TaxAmount          interface{}     `json:"tax_amount"`
	DiscountPercentage interface{}     `json:"discount_percentage"`
	DiscountAmount     interface{}     `json:"discount_amount"`
	TotalAmount        decimal.Decimal `json:"total_amount"`
	CreatedAt          interface{}     `json:"created_at"`
	UpdatedAt          interface{}     `json:"updated_at"`
}

func (q *Queries) CreateInvoiceItem(ctx context.Context, arg CreateInvoiceItemParams) (InvoiceItems, error) {
	row := q.db.QueryRow(ctx, createInvoiceItem,
		arg.ID,
		arg.InvoiceID,
		arg.Description,
		arg.Quantity,
		arg.UnitPrice,
		arg.Amount,
		arg.TaxRate,
		arg.TaxAmount,
		arg.DiscountPercentage,
		arg.DiscountAmount,
		arg.TotalAmount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InvoiceItems
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitPrice,
		&i.Amount,
		&i.TaxRate,
		&i.TaxAmount,
		&i.DiscountPercentage,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvoiceItem = `-- name: DeleteInvoiceItem :exec
DELETE FROM invoice_items WHERE id = $1
`

func (q *Queries) DeleteInvoiceItem(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInvoiceItem, id)
	return err
}

const getCompanyReceivedInvoices = `-- name: GetCompanyReceivedInvoices :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE i.recipient_id = $1
ORDER BY i.created_at DESC
LIMIT $3 OFFSET $2
`

type GetCompanyReceivedInvoicesParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetCompanyReceivedInvoicesRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
}

func (q *Queries) GetCompanyReceivedInvoices(ctx context.Context, arg GetCompanyReceivedInvoicesParams) ([]GetCompanyReceivedInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getCompanyReceivedInvoices, arg.CompanyID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanyReceivedInvoicesRow{}
	for rows.Next() {
		var i GetCompanyReceivedInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IssuerEmail,
			&i.IssuerFirstName,
			&i.IssuerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanySentInvoices = `-- name: GetCompanySentInvoices :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN companies recipient ON i.recipient_id = recipient.id
JOIN company_users cu ON cu.company_id = recipient.id
WHERE cu.user_id = $1 AND i.issuer_id = $1
ORDER BY i.created_at DESC
LIMIT $3 OFFSET $2
`

type GetCompanySentInvoicesParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetCompanySentInvoicesRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetCompanySentInvoices(ctx context.Context, arg GetCompanySentInvoicesParams) ([]GetCompanySentInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getCompanySentInvoices, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompanySentInvoicesRow{}
	for rows.Next() {
		var i GetCompanySentInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecipientCompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoiceByID = `-- name: GetInvoiceByID :one
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name,
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN companies recipient ON i.recipient_id = recipient.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE i.id = $1
`

type GetInvoiceByIDRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetInvoiceByID(ctx context.Context, id uuid.UUID) (GetInvoiceByIDRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceByID, id)
	var i GetInvoiceByIDRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.IssuerID,
		&i.RecipientID,
		&i.Title,
		&i.Description,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.TransactionHash,
		&i.PaymentDate,
		&i.RejectionReason,
		&i.IpfsHash,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IssuerEmail,
		&i.IssuerFirstName,
		&i.IssuerLastName,
		&i.RecipientCompanyName,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name,
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN companies recipient ON i.recipient_id = recipient.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE i.invoice_number = $1
`

type GetInvoiceByNumberRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetInvoiceByNumber(ctx context.Context, invoiceNumber string) (GetInvoiceByNumberRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceByNumber, invoiceNumber)
	var i GetInvoiceByNumberRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.IssuerID,
		&i.RecipientID,
		&i.Title,
		&i.Description,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.TransactionHash,
		&i.PaymentDate,
		&i.RejectionReason,
		&i.IpfsHash,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IssuerEmail,
		&i.IssuerFirstName,
		&i.IssuerLastName,
		&i.RecipientCompanyName,
	)
	return i, err
}

const getInvoiceItems = `-- name: GetInvoiceItems :many
SELECT id, invoice_id, description, quantity, unit_price, amount, tax_rate, tax_amount, discount_percentage, discount_amount, total_amount, created_at, updated_at FROM invoice_items 
WHERE invoice_id = $1
ORDER BY created_at
`

func (q *Queries) GetInvoiceItems(ctx context.Context, invoiceID uuid.UUID) ([]InvoiceItems, error) {
	rows, err := q.db.Query(ctx, getInvoiceItems, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceItems{}
	for rows.Next() {
		var i InvoiceItems
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.Description,
			&i.Quantity,
			&i.UnitPrice,
			&i.Amount,
			&i.TaxRate,
			&i.TaxAmount,
			&i.DiscountPercentage,
			&i.DiscountAmount,
			&i.TotalAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesByStatus = `-- name: GetInvoicesByStatus :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name,
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN companies recipient ON i.recipient_id = recipient.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE i.status = $1
  AND ($2::uuid IS NULL OR i.recipient_id = $2)
  AND ($3::uuid IS NULL OR i.issuer_id = $3)
ORDER BY i.created_at DESC
LIMIT $5 OFFSET $4
`

type GetInvoicesByStatusParams struct {
	Status    pgtype.Text `json:"status"`
	CompanyID uuid.UUID   `json:"company_id"`
	UserID    uuid.UUID   `json:"user_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetInvoicesByStatusRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetInvoicesByStatus(ctx context.Context, arg GetInvoicesByStatusParams) ([]GetInvoicesByStatusRow, error) {
	rows, err := q.db.Query(ctx, getInvoicesByStatus,
		arg.Status,
		arg.CompanyID,
		arg.UserID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoicesByStatusRow{}
	for rows.Next() {
		var i GetInvoicesByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IssuerEmail,
			&i.IssuerFirstName,
			&i.IssuerLastName,
			&i.RecipientCompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvoicesForApproval = `-- name: GetInvoicesForApproval :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN company_users cu ON cu.company_id = i.recipient_id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE cu.user_id = $1 
  AND i.status = 'pending'
  AND (cu.can_manage_invoices = TRUE OR cu.is_administrator = TRUE)
ORDER BY i.created_at
`

type GetInvoicesForApprovalRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
}

func (q *Queries) GetInvoicesForApproval(ctx context.Context, userID uuid.UUID) ([]GetInvoicesForApprovalRow, error) {
	rows, err := q.db.Query(ctx, getInvoicesForApproval, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoicesForApprovalRow{}
	for rows.Next() {
		var i GetInvoicesForApprovalRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IssuerEmail,
			&i.IssuerFirstName,
			&i.IssuerLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverdueInvoices = `-- name: GetOverdueInvoices :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name,
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN companies recipient ON i.recipient_id = recipient.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE i.due_date < CURRENT_DATE 
  AND i.status NOT IN ('paid', 'cancelled')
  AND ($1::uuid IS NULL OR i.recipient_id = $1)
  AND ($2::uuid IS NULL OR i.issuer_id = $2)
ORDER BY i.due_date
`

type GetOverdueInvoicesParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	UserID    uuid.UUID `json:"user_id"`
}

type GetOverdueInvoicesRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetOverdueInvoices(ctx context.Context, arg GetOverdueInvoicesParams) ([]GetOverdueInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getOverdueInvoices, arg.CompanyID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverdueInvoicesRow{}
	for rows.Next() {
		var i GetOverdueInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IssuerEmail,
			&i.IssuerFirstName,
			&i.IssuerLastName,
			&i.RecipientCompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInvoices = `-- name: GetUserInvoices :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN companies recipient ON i.recipient_id = recipient.id
WHERE i.issuer_id = $1
ORDER BY i.created_at DESC
LIMIT $3 OFFSET $2
`

type GetUserInvoicesParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetUserInvoicesRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) GetUserInvoices(ctx context.Context, arg GetUserInvoicesParams) ([]GetUserInvoicesRow, error) {
	rows, err := q.db.Query(ctx, getUserInvoices, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserInvoicesRow{}
	for rows.Next() {
		var i GetUserInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RecipientCompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchInvoices = `-- name: SearchInvoices :many
SELECT i.id, i.invoice_number, i.issuer_id, i.recipient_id, i.title, i.description, i.issue_date, i.due_date, i.total_amount, i.currency, i.status, i.payment_method, i.recipient_wallet_address, i.recipient_bank_account_id, i.transaction_hash, i.payment_date, i.rejection_reason, i.ipfs_hash, i.smart_contract_address, i.chain_id, i.created_at, i.updated_at, 
       issuer.email as issuer_email,
       COALESCE(issuer_profile.first_name, issuer_personal.first_name) as issuer_first_name,
       COALESCE(issuer_profile.last_name, issuer_personal.last_name) as issuer_last_name,
       recipient.company_name as recipient_company_name
FROM invoices i
JOIN users issuer ON i.issuer_id = issuer.id
JOIN companies recipient ON i.recipient_id = recipient.id
LEFT JOIN company_staff_profiles issuer_profile ON issuer.id = issuer_profile.id
LEFT JOIN personal_users issuer_personal ON issuer.id = issuer_personal.id
WHERE (i.issuer_id = $1 OR i.recipient_id IN (
    SELECT company_id FROM company_users WHERE user_id = $1
))
AND (
    i.invoice_number ILIKE '%' || $2 || '%' OR
    i.title ILIKE '%' || $2 || '%' OR
    recipient.company_name ILIKE '%' || $2 || '%'
)
ORDER BY i.created_at DESC
LIMIT $4 OFFSET $3
`

type SearchInvoicesParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	SearchTerm pgtype.Text `json:"search_term"`
	OffsetVal  int32       `json:"offset_val"`
	LimitVal   int32       `json:"limit_val"`
}

type SearchInvoicesRow struct {
	ID                     uuid.UUID          `json:"id"`
	InvoiceNumber          string             `json:"invoice_number"`
	IssuerID               uuid.UUID          `json:"issuer_id"`
	RecipientID            uuid.UUID          `json:"recipient_id"`
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	IssuerEmail            string             `json:"issuer_email"`
	IssuerFirstName        pgtype.Text        `json:"issuer_first_name"`
	IssuerLastName         pgtype.Text        `json:"issuer_last_name"`
	RecipientCompanyName   string             `json:"recipient_company_name"`
}

func (q *Queries) SearchInvoices(ctx context.Context, arg SearchInvoicesParams) ([]SearchInvoicesRow, error) {
	rows, err := q.db.Query(ctx, searchInvoices,
		arg.UserID,
		arg.SearchTerm,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchInvoicesRow{}
	for rows.Next() {
		var i SearchInvoicesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.IssuerID,
			&i.RecipientID,
			&i.Title,
			&i.Description,
			&i.IssueDate,
			&i.DueDate,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.PaymentMethod,
			&i.RecipientWalletAddress,
			&i.RecipientBankAccountID,
			&i.TransactionHash,
			&i.PaymentDate,
			&i.RejectionReason,
			&i.IpfsHash,
			&i.SmartContractAddress,
			&i.ChainID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IssuerEmail,
			&i.IssuerFirstName,
			&i.IssuerLastName,
			&i.RecipientCompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :one
UPDATE invoices SET
  title = COALESCE($1, title),
  description = COALESCE($2, description),
  issue_date = COALESCE($3, issue_date),
  due_date = COALESCE($4, due_date),
  total_amount = COALESCE($5, total_amount),
  currency = COALESCE($6, currency),
  status = COALESCE($7, status),
  payment_method = COALESCE($8, payment_method),
  recipient_wallet_address = COALESCE($9, recipient_wallet_address),
  recipient_bank_account_id = COALESCE($10, recipient_bank_account_id),
  transaction_hash = COALESCE($11, transaction_hash),
  payment_date = COALESCE($12, payment_date),
  rejection_reason = COALESCE($13, rejection_reason),
  ipfs_hash = COALESCE($14, ipfs_hash),
  smart_contract_address = COALESCE($15, smart_contract_address),
  chain_id = COALESCE($16, chain_id),
  updated_at = NOW()
WHERE id = $17
RETURNING id, invoice_number, issuer_id, recipient_id, title, description, issue_date, due_date, total_amount, currency, status, payment_method, recipient_wallet_address, recipient_bank_account_id, transaction_hash, payment_date, rejection_reason, ipfs_hash, smart_contract_address, chain_id, created_at, updated_at
`

type UpdateInvoiceParams struct {
	Title                  string             `json:"title"`
	Description            pgtype.Text        `json:"description"`
	IssueDate              pgtype.Date        `json:"issue_date"`
	DueDate                pgtype.Date        `json:"due_date"`
	TotalAmount            decimal.Decimal    `json:"total_amount"`
	Currency               string             `json:"currency"`
	Status                 pgtype.Text        `json:"status"`
	PaymentMethod          pgtype.Text        `json:"payment_method"`
	RecipientWalletAddress pgtype.Text        `json:"recipient_wallet_address"`
	RecipientBankAccountID pgtype.UUID        `json:"recipient_bank_account_id"`
	TransactionHash        pgtype.Text        `json:"transaction_hash"`
	PaymentDate            pgtype.Timestamptz `json:"payment_date"`
	RejectionReason        pgtype.Text        `json:"rejection_reason"`
	IpfsHash               pgtype.Text        `json:"ipfs_hash"`
	SmartContractAddress   pgtype.Text        `json:"smart_contract_address"`
	ChainID                pgtype.Int4        `json:"chain_id"`
	ID                     uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) (Invoices, error) {
	row := q.db.QueryRow(ctx, updateInvoice,
		arg.Title,
		arg.Description,
		arg.IssueDate,
		arg.DueDate,
		arg.TotalAmount,
		arg.Currency,
		arg.Status,
		arg.PaymentMethod,
		arg.RecipientWalletAddress,
		arg.RecipientBankAccountID,
		arg.TransactionHash,
		arg.PaymentDate,
		arg.RejectionReason,
		arg.IpfsHash,
		arg.SmartContractAddress,
		arg.ChainID,
		arg.ID,
	)
	var i Invoices
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.IssuerID,
		&i.RecipientID,
		&i.Title,
		&i.Description,
		&i.IssueDate,
		&i.DueDate,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.PaymentMethod,
		&i.RecipientWalletAddress,
		&i.RecipientBankAccountID,
		&i.TransactionHash,
		&i.PaymentDate,
		&i.RejectionReason,
		&i.IpfsHash,
		&i.SmartContractAddress,
		&i.ChainID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateInvoiceItem = `-- name: UpdateInvoiceItem :one
UPDATE invoice_items SET
  description = COALESCE($1, description),
  quantity = COALESCE($2, quantity),
  unit_price = COALESCE($3, unit_price),
  amount = COALESCE($4, amount),
  tax_rate = COALESCE($5, tax_rate),
  tax_amount = COALESCE($6, tax_amount),
  discount_percentage = COALESCE($7, discount_percentage),
  discount_amount = COALESCE($8, discount_amount),
  total_amount = COALESCE($9, total_amount),
  updated_at = NOW()
WHERE id = $10
RETURNING id, invoice_id, description, quantity, unit_price, amount, tax_rate, tax_amount, discount_percentage, discount_amount, total_amount, created_at, updated_at
`

type UpdateInvoiceItemParams struct {
	Description        string          `json:"description"`
	Quantity           decimal.Decimal `json:"quantity"`
	UnitPrice          decimal.Decimal `json:"unit_price"`
	Amount             decimal.Decimal `json:"amount"`
	TaxRate            pgtype.Numeric  `json:"tax_rate"`
	TaxAmount          pgtype.Numeric  `json:"tax_amount"`
	DiscountPercentage pgtype.Numeric  `json:"discount_percentage"`
	DiscountAmount     pgtype.Numeric  `json:"discount_amount"`
	TotalAmount        decimal.Decimal `json:"total_amount"`
	ID                 uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateInvoiceItem(ctx context.Context, arg UpdateInvoiceItemParams) (InvoiceItems, error) {
	row := q.db.QueryRow(ctx, updateInvoiceItem,
		arg.Description,
		arg.Quantity,
		arg.UnitPrice,
		arg.Amount,
		arg.TaxRate,
		arg.TaxAmount,
		arg.DiscountPercentage,
		arg.DiscountAmount,
		arg.TotalAmount,
		arg.ID,
	)
	var i InvoiceItems
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.Description,
		&i.Quantity,
		&i.UnitPrice,
		&i.Amount,
		&i.TaxRate,
		&i.TaxAmount,
		&i.DiscountPercentage,
		&i.DiscountAmount,
		&i.TotalAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
