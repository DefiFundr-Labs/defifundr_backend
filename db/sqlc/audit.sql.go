// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupOldActivityLogs = `-- name: CleanupOldActivityLogs :exec
DELETE FROM activity_logs 
WHERE created_at < NOW() - INTERVAL '@days days'
`

func (q *Queries) CleanupOldActivityLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldActivityLogs)
	return err
}

const cleanupOldAuditLogs = `-- name: CleanupOldAuditLogs :exec
DELETE FROM audit_logs 
WHERE created_at < NOW() - INTERVAL '@days days'
`

func (q *Queries) CleanupOldAuditLogs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldAuditLogs)
	return err
}

const createActivityLog = `-- name: CreateActivityLog :one
INSERT INTO activity_logs (
  id,
  user_id,
  activity_type,
  description,
  metadata,
  ip_address,
  user_agent,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  COALESCE($8, NOW())
) RETURNING id, user_id, activity_type, description, metadata, ip_address, user_agent, created_at
`

type CreateActivityLogParams struct {
	ID           interface{} `json:"id"`
	UserID       uuid.UUID   `json:"user_id"`
	ActivityType string      `json:"activity_type"`
	Description  pgtype.Text `json:"description"`
	Metadata     []byte      `json:"metadata"`
	IpAddress    pgtype.Text `json:"ip_address"`
	UserAgent    pgtype.Text `json:"user_agent"`
	CreatedAt    interface{} `json:"created_at"`
}

func (q *Queries) CreateActivityLog(ctx context.Context, arg CreateActivityLogParams) (ActivityLogs, error) {
	row := q.db.QueryRow(ctx, createActivityLog,
		arg.ID,
		arg.UserID,
		arg.ActivityType,
		arg.Description,
		arg.Metadata,
		arg.IpAddress,
		arg.UserAgent,
		arg.CreatedAt,
	)
	var i ActivityLogs
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ActivityType,
		&i.Description,
		&i.Metadata,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (
  id,
  user_id,
  company_id,
  action,
  entity_type,
  entity_id,
  previous_state,
  new_state,
  ip_address,
  user_agent,
  created_at
) VALUES (
  COALESCE($1, uuid_generate_v4()),
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  COALESCE($11, NOW())
) RETURNING id, user_id, company_id, action, entity_type, entity_id, previous_state, new_state, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	ID            interface{} `json:"id"`
	UserID        pgtype.UUID `json:"user_id"`
	CompanyID     pgtype.UUID `json:"company_id"`
	Action        string      `json:"action"`
	EntityType    string      `json:"entity_type"`
	EntityID      uuid.UUID   `json:"entity_id"`
	PreviousState []byte      `json:"previous_state"`
	NewState      []byte      `json:"new_state"`
	IpAddress     pgtype.Text `json:"ip_address"`
	UserAgent     pgtype.Text `json:"user_agent"`
	CreatedAt     interface{} `json:"created_at"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLogs, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.ID,
		arg.UserID,
		arg.CompanyID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.PreviousState,
		arg.NewState,
		arg.IpAddress,
		arg.UserAgent,
		arg.CreatedAt,
	)
	var i AuditLogs
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CompanyID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.PreviousState,
		&i.NewState,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityLogsByType = `-- name: GetActivityLogsByType :many
SELECT al.id, al.user_id, al.activity_type, al.description, al.metadata, al.ip_address, al.user_agent, al.created_at, u.email
FROM activity_logs al
JOIN users u ON al.user_id = u.id
WHERE al.activity_type = $1
  AND ($2::uuid IS NULL OR al.user_id = $2)
  AND ($3::timestamptz IS NULL OR al.created_at >= $3)
  AND ($4::timestamptz IS NULL OR al.created_at <= $4)
ORDER BY al.created_at DESC
LIMIT $6 OFFSET $5
`

type GetActivityLogsByTypeParams struct {
	ActivityType string    `json:"activity_type"`
	UserID       uuid.UUID `json:"user_id"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	OffsetVal    int32     `json:"offset_val"`
	LimitVal     int32     `json:"limit_val"`
}

type GetActivityLogsByTypeRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	ActivityType string             `json:"activity_type"`
	Description  pgtype.Text        `json:"description"`
	Metadata     []byte             `json:"metadata"`
	IpAddress    pgtype.Text        `json:"ip_address"`
	UserAgent    pgtype.Text        `json:"user_agent"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Email        string             `json:"email"`
}

func (q *Queries) GetActivityLogsByType(ctx context.Context, arg GetActivityLogsByTypeParams) ([]GetActivityLogsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getActivityLogsByType,
		arg.ActivityType,
		arg.UserID,
		arg.StartDate,
		arg.EndDate,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityLogsByTypeRow{}
	for rows.Next() {
		var i GetActivityLogsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActivityType,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityLogsByUser = `-- name: GetActivityLogsByUser :many
SELECT id, user_id, activity_type, description, metadata, ip_address, user_agent, created_at FROM activity_logs 
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetActivityLogsByUserParams struct {
	UserID    uuid.UUID `json:"user_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

func (q *Queries) GetActivityLogsByUser(ctx context.Context, arg GetActivityLogsByUserParams) ([]ActivityLogs, error) {
	rows, err := q.db.Query(ctx, getActivityLogsByUser, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityLogs{}
	for rows.Next() {
		var i ActivityLogs
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActivityType,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByAction = `-- name: GetAuditLogsByAction :many
SELECT al.id, al.user_id, al.company_id, al.action, al.entity_type, al.entity_id, al.previous_state, al.new_state, al.ip_address, al.user_agent, al.created_at, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.action = $1
  AND ($2::uuid IS NULL OR al.user_id = $2)
  AND ($3::uuid IS NULL OR al.company_id = $3)
  AND ($4::timestamptz IS NULL OR al.created_at >= $4)
  AND ($5::timestamptz IS NULL OR al.created_at <= $5)
ORDER BY al.created_at DESC
LIMIT $7 OFFSET $6
`

type GetAuditLogsByActionParams struct {
	Action    string    `json:"action"`
	UserID    uuid.UUID `json:"user_id"`
	CompanyID uuid.UUID `json:"company_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetAuditLogsByActionRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyID     pgtype.UUID        `json:"company_id"`
	Action        string             `json:"action"`
	EntityType    string             `json:"entity_type"`
	EntityID      uuid.UUID          `json:"entity_id"`
	PreviousState []byte             `json:"previous_state"`
	NewState      []byte             `json:"new_state"`
	IpAddress     pgtype.Text        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         pgtype.Text        `json:"email"`
}

func (q *Queries) GetAuditLogsByAction(ctx context.Context, arg GetAuditLogsByActionParams) ([]GetAuditLogsByActionRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByAction,
		arg.Action,
		arg.UserID,
		arg.CompanyID,
		arg.StartDate,
		arg.EndDate,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByActionRow{}
	for rows.Next() {
		var i GetAuditLogsByActionRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.PreviousState,
			&i.NewState,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByCompany = `-- name: GetAuditLogsByCompany :many
SELECT al.id, al.user_id, al.company_id, al.action, al.entity_type, al.entity_id, al.previous_state, al.new_state, al.ip_address, al.user_agent, al.created_at, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.company_id = $1
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $2
`

type GetAuditLogsByCompanyParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetAuditLogsByCompanyRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyID     pgtype.UUID        `json:"company_id"`
	Action        string             `json:"action"`
	EntityType    string             `json:"entity_type"`
	EntityID      uuid.UUID          `json:"entity_id"`
	PreviousState []byte             `json:"previous_state"`
	NewState      []byte             `json:"new_state"`
	IpAddress     pgtype.Text        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         pgtype.Text        `json:"email"`
}

func (q *Queries) GetAuditLogsByCompany(ctx context.Context, arg GetAuditLogsByCompanyParams) ([]GetAuditLogsByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByCompany, arg.CompanyID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByCompanyRow{}
	for rows.Next() {
		var i GetAuditLogsByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.PreviousState,
			&i.NewState,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByEntity = `-- name: GetAuditLogsByEntity :many
SELECT al.id, al.user_id, al.company_id, al.action, al.entity_type, al.entity_id, al.previous_state, al.new_state, al.ip_address, al.user_agent, al.created_at, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.entity_type = $1 AND al.entity_id = $2
ORDER BY al.created_at DESC
LIMIT $4 OFFSET $3
`

type GetAuditLogsByEntityParams struct {
	EntityType string    `json:"entity_type"`
	EntityID   uuid.UUID `json:"entity_id"`
	OffsetVal  int32     `json:"offset_val"`
	LimitVal   int32     `json:"limit_val"`
}

type GetAuditLogsByEntityRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyID     pgtype.UUID        `json:"company_id"`
	Action        string             `json:"action"`
	EntityType    string             `json:"entity_type"`
	EntityID      uuid.UUID          `json:"entity_id"`
	PreviousState []byte             `json:"previous_state"`
	NewState      []byte             `json:"new_state"`
	IpAddress     pgtype.Text        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         pgtype.Text        `json:"email"`
}

func (q *Queries) GetAuditLogsByEntity(ctx context.Context, arg GetAuditLogsByEntityParams) ([]GetAuditLogsByEntityRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByEntity,
		arg.EntityType,
		arg.EntityID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByEntityRow{}
	for rows.Next() {
		var i GetAuditLogsByEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.PreviousState,
			&i.NewState,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByUser = `-- name: GetAuditLogsByUser :many
SELECT al.id, al.user_id, al.company_id, al.action, al.entity_type, al.entity_id, al.previous_state, al.new_state, al.ip_address, al.user_agent, al.created_at, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE al.user_id = $1
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $2
`

type GetAuditLogsByUserParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	OffsetVal int32       `json:"offset_val"`
	LimitVal  int32       `json:"limit_val"`
}

type GetAuditLogsByUserRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyID     pgtype.UUID        `json:"company_id"`
	Action        string             `json:"action"`
	EntityType    string             `json:"entity_type"`
	EntityID      uuid.UUID          `json:"entity_id"`
	PreviousState []byte             `json:"previous_state"`
	NewState      []byte             `json:"new_state"`
	IpAddress     pgtype.Text        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         pgtype.Text        `json:"email"`
}

func (q *Queries) GetAuditLogsByUser(ctx context.Context, arg GetAuditLogsByUserParams) ([]GetAuditLogsByUserRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByUser, arg.UserID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsByUserRow{}
	for rows.Next() {
		var i GetAuditLogsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.PreviousState,
			&i.NewState,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyAuditSummary = `-- name: GetCompanyAuditSummary :one
SELECT 
  COUNT(*) as total_audit_logs,
  COUNT(DISTINCT user_id) as unique_users,
  COUNT(DISTINCT action) as unique_actions,
  COUNT(DISTINCT entity_type) as unique_entity_types,
  MAX(created_at) as last_audit,
  MIN(created_at) as first_audit
FROM audit_logs 
WHERE company_id = $1
  AND ($2::timestamptz IS NULL OR created_at >= $2)
  AND ($3::timestamptz IS NULL OR created_at <= $3)
`

type GetCompanyAuditSummaryParams struct {
	CompanyID pgtype.UUID `json:"company_id"`
	StartDate time.Time   `json:"start_date"`
	EndDate   time.Time   `json:"end_date"`
}

type GetCompanyAuditSummaryRow struct {
	TotalAuditLogs    int64       `json:"total_audit_logs"`
	UniqueUsers       int64       `json:"unique_users"`
	UniqueActions     int64       `json:"unique_actions"`
	UniqueEntityTypes int64       `json:"unique_entity_types"`
	LastAudit         interface{} `json:"last_audit"`
	FirstAudit        interface{} `json:"first_audit"`
}

func (q *Queries) GetCompanyAuditSummary(ctx context.Context, arg GetCompanyAuditSummaryParams) (GetCompanyAuditSummaryRow, error) {
	row := q.db.QueryRow(ctx, getCompanyAuditSummary, arg.CompanyID, arg.StartDate, arg.EndDate)
	var i GetCompanyAuditSummaryRow
	err := row.Scan(
		&i.TotalAuditLogs,
		&i.UniqueUsers,
		&i.UniqueActions,
		&i.UniqueEntityTypes,
		&i.LastAudit,
		&i.FirstAudit,
	)
	return i, err
}

const getRecentActivity = `-- name: GetRecentActivity :many
SELECT al.id, al.user_id, al.activity_type, al.description, al.metadata, al.ip_address, al.user_agent, al.created_at, u.email,
       COALESCE(csp.first_name, pu.first_name) as first_name,
       COALESCE(csp.last_name, pu.last_name) as last_name
FROM activity_logs al
JOIN users u ON al.user_id = u.id
LEFT JOIN company_staff_profiles csp ON u.id = csp.id
LEFT JOIN personal_users pu ON u.id = pu.id
WHERE ($1::uuid IS NULL OR al.user_id = $1)
  AND al.created_at >= NOW() - INTERVAL '@hours hours'
ORDER BY al.created_at DESC
LIMIT $2
`

type GetRecentActivityParams struct {
	UserID   uuid.UUID `json:"user_id"`
	LimitVal int32     `json:"limit_val"`
}

type GetRecentActivityRow struct {
	ID           uuid.UUID          `json:"id"`
	UserID       uuid.UUID          `json:"user_id"`
	ActivityType string             `json:"activity_type"`
	Description  pgtype.Text        `json:"description"`
	Metadata     []byte             `json:"metadata"`
	IpAddress    pgtype.Text        `json:"ip_address"`
	UserAgent    pgtype.Text        `json:"user_agent"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	Email        string             `json:"email"`
	FirstName    pgtype.Text        `json:"first_name"`
	LastName     pgtype.Text        `json:"last_name"`
}

func (q *Queries) GetRecentActivity(ctx context.Context, arg GetRecentActivityParams) ([]GetRecentActivityRow, error) {
	rows, err := q.db.Query(ctx, getRecentActivity, arg.UserID, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentActivityRow{}
	for rows.Next() {
		var i GetRecentActivityRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ActivityType,
			&i.Description,
			&i.Metadata,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActivitySummary = `-- name: GetUserActivitySummary :one
SELECT 
  COUNT(*) as total_activities,
  COUNT(DISTINCT activity_type) as unique_activity_types,
  MAX(created_at) as last_activity,
  MIN(created_at) as first_activity
FROM activity_logs 
WHERE user_id = $1
  AND ($2::timestamptz IS NULL OR created_at >= $2)
  AND ($3::timestamptz IS NULL OR created_at <= $3)
`

type GetUserActivitySummaryParams struct {
	UserID    uuid.UUID `json:"user_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type GetUserActivitySummaryRow struct {
	TotalActivities     int64       `json:"total_activities"`
	UniqueActivityTypes int64       `json:"unique_activity_types"`
	LastActivity        interface{} `json:"last_activity"`
	FirstActivity       interface{} `json:"first_activity"`
}

func (q *Queries) GetUserActivitySummary(ctx context.Context, arg GetUserActivitySummaryParams) (GetUserActivitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserActivitySummary, arg.UserID, arg.StartDate, arg.EndDate)
	var i GetUserActivitySummaryRow
	err := row.Scan(
		&i.TotalActivities,
		&i.UniqueActivityTypes,
		&i.LastActivity,
		&i.FirstActivity,
	)
	return i, err
}

const searchAuditLogs = `-- name: SearchAuditLogs :many
SELECT al.id, al.user_id, al.company_id, al.action, al.entity_type, al.entity_id, al.previous_state, al.new_state, al.ip_address, al.user_agent, al.created_at, u.email
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
WHERE ($1::uuid IS NULL OR al.user_id = $1)
  AND ($2::uuid IS NULL OR al.company_id = $2)
  AND ($3::text IS NULL OR al.entity_type = $3)
  AND ($4::text IS NULL OR al.action = $4)
  AND ($5::timestamptz IS NULL OR al.created_at >= $5)
  AND ($6::timestamptz IS NULL OR al.created_at <= $6)
ORDER BY al.created_at DESC
LIMIT $8 OFFSET $7
`

type SearchAuditLogsParams struct {
	UserID     uuid.UUID `json:"user_id"`
	CompanyID  uuid.UUID `json:"company_id"`
	EntityType string    `json:"entity_type"`
	Action     string    `json:"action"`
	StartDate  time.Time `json:"start_date"`
	EndDate    time.Time `json:"end_date"`
	OffsetVal  int32     `json:"offset_val"`
	LimitVal   int32     `json:"limit_val"`
}

type SearchAuditLogsRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        pgtype.UUID        `json:"user_id"`
	CompanyID     pgtype.UUID        `json:"company_id"`
	Action        string             `json:"action"`
	EntityType    string             `json:"entity_type"`
	EntityID      uuid.UUID          `json:"entity_id"`
	PreviousState []byte             `json:"previous_state"`
	NewState      []byte             `json:"new_state"`
	IpAddress     pgtype.Text        `json:"ip_address"`
	UserAgent     pgtype.Text        `json:"user_agent"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Email         pgtype.Text        `json:"email"`
}

func (q *Queries) SearchAuditLogs(ctx context.Context, arg SearchAuditLogsParams) ([]SearchAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, searchAuditLogs,
		arg.UserID,
		arg.CompanyID,
		arg.EntityType,
		arg.Action,
		arg.StartDate,
		arg.EndDate,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAuditLogsRow{}
	for rows.Next() {
		var i SearchAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CompanyID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.PreviousState,
			&i.NewState,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
